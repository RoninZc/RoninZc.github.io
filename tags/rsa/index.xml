<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>RSA - 标签 - &lt;p&gt;RoninZc 的个人博客&lt;/p&gt;</title>
    <link>https://ronin-zc.com/tags/rsa/</link>
    <description>RSA - 标签 - &lt;p&gt;RoninZc 的个人博客&lt;/p&gt;</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>devroninzc@gmail.com (RoninZc)</managingEditor>
      <webMaster>devroninzc@gmail.com (RoninZc)</webMaster><lastBuildDate>Wed, 03 Mar 2021 13:47:25 &#43;0800</lastBuildDate><atom:link href="https://ronin-zc.com/tags/rsa/" rel="self" type="application/rss+xml" /><item>
  <title>RSA(七) X.509 自签名证书</title>
  <link>https://ronin-zc.com/rsa%E4%B8%83-x.509-%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</link>
  <pubDate>Wed, 03 Mar 2021 13:47:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E4%B8%83-x.509-%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>继前文<a
  href="https://www.shangyang.me/2017/05/27/encrypt-rsa-x509/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(六) X.509 CA 证书</a> 所述，<em>X.509 CA</em> 证书是由 𝐶𝐴CA 认证中心签名并颁发的；但是最后，作者留下了这么一个疑问，就是如果在企业内网，我同样需要对公钥进行认证，但是因为不需要连接外网，所以并不需要 𝐶𝐴CA 证书(因为，𝐶𝐴CA 证书毕竟开销不菲)；那么是否有这样的一种可替代的方案，在不使用 𝐶𝐴CA 证书的前提下，能否保证公钥的合法性？答案是<code>自签名证书</code>；</p>
<p>备注，本文是作者的原创作品，转载请注明出处。</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/27/encrypt-rsa-selfsigned-certificate/</code></p>
</blockquote>
<h1 id="定义">定义</h1>
<p>看下 wikipedia <a
  href="https://en.wikipedia.org/wiki/Self-signed_certificate"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/Self-signed_certificate</a> 上的最重要的一段解释</p>
<blockquote>
<p>In technical terms a self-signed certificate is one signed with its own private key.</p>
</blockquote>
<p>自签名证书说穿了，就是一个由自己的私钥进行签名的证书；</p>
<h1 id="与-ca-证书的区别">与 CA 证书的区别</h1>
<p>通过 <a
  href="https://www.shangyang.me/2017/05/27/encrypt-rsa-x509/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(六) X.509 CA 证书</a> 章节我们知道，要保证公钥的合法性，我们需要把自己的公钥交给第三方 𝐶𝐴CA 机构，通过它的私钥来进行签名，并生成一张 𝐶𝐴CA 证书并颁发给用户；而与 𝐶𝐴CA 证书相对应的就是自签名证书，也就是说，我自己的公钥不交给第三方的 𝐶𝐴CA 机构进行签名，而是直接由自己的私钥进行签名，并生成一张自签名的证书；</p>
<h1 id="如何生成">如何生成</h1>
<p>这里我主要讲解一下，如果通过 <em>openssl</em> 来生成自签名的证书，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl req \
</span></span><span class="line"><span class="cl">&gt;        -newkey rsa:2048 -nodes -keyout private.key \
</span></span><span class="line"><span class="cl">&gt;        -x509 -days 365 -out self-signed.crt
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后同样需要输入 <a
  href="https://www.shangyang.me/2017/05/27/encrypt-rsa-x509/#%e9%80%9a%e8%bf%87-CSR-%e7%94%b3%e8%af%b7-X509-CA-%e8%af%81%e4%b9%a6"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>CSR 相关的信息</a>来申请；最后，会在本地目录中生成一个私钥 <em>private.key</em> 和一张自签名的证书 <em>self-signed.crt</em>；注意，自签名证书文件的后缀为 <em>.crt</em>；下面来看看各个参数的简要说明，</p>
<p><code>-x509</code>告诉 openssl 生成一张自签名的证书；
<code>-nodes</code>告诉 openssl 在生成私钥的时候忽略密码</p>
<p>参考
<a
  href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-16-04"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>How To Create a Self-Signed SSL Certificate for Apache in Ubuntu 16.04</a></p>
<p><a
  href="https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>OpenSSL Essentials: Working with SSL Certificates, Private Keys and CSRs</a></p>
<h1 id="内部结构">内部结构</h1>
<p>我们来查看一下刚才通过 openssl 生成的自签名证书 <em>self-signed.crt</em> 的内部结构；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl x509 -text -noout -in domain.crt
</span></span></code></pre></td></tr></table>
</div>
</div><p>内容如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Certificate:
</span></span><span class="line"><span class="cl">    Data:
</span></span><span class="line"><span class="cl">        Version: 3 (0x2)
</span></span><span class="line"><span class="cl">        Serial Number:
</span></span><span class="line"><span class="cl">            9f:56:fd:f5:9d:13:2e:d2
</span></span><span class="line"><span class="cl">        Signature Algorithm: sha1WithRSAEncryption
</span></span><span class="line"><span class="cl">        Issuer: C=CN, ST=ChengDu, L=ChengDu, O=HRX, OU=HRX, CN=HRX/emailAddress=comedshang@163.com
</span></span><span class="line"><span class="cl">        Validity
</span></span><span class="line"><span class="cl">            Not Before: May 27 13:42:23 2017 GMT
</span></span><span class="line"><span class="cl">            Not After : May 27 13:42:23 2018 GMT
</span></span><span class="line"><span class="cl">        Subject: C=CN, ST=ChengDu, L=ChengDu, O=HRX, OU=HRX, CN=HRX/emailAddress=comedshang@163.com
</span></span><span class="line"><span class="cl">        Subject Public Key Info:
</span></span><span class="line"><span class="cl">            Public Key Algorithm: rsaEncryption
</span></span><span class="line"><span class="cl">            RSA Public Key: (2048 bit)
</span></span><span class="line"><span class="cl">                Modulus (2048 bit):
</span></span><span class="line"><span class="cl">                    00:e5:06:e7:94:b4:ff:ad:ae:26:9c:2c:76:2e:d2:
</span></span><span class="line"><span class="cl">                    c7:f6:b3:51:9a:15:1f:d6:6f:ee:f7:7b:13:61:b5:
</span></span><span class="line"><span class="cl">                    d5:07:de:6f:e4:78:05:cc:b3:74:fc:c4:ec:7f:07:
</span></span><span class="line"><span class="cl">                    c7:b3:1b:c3:b6:c5:e8:9a:00:48:5c:e3:7c:51:e2:
</span></span><span class="line"><span class="cl">                    34:1d:0e:e0:2f:4f:3d:4a:68:e3:fd:b4:c2:79:7f:
</span></span><span class="line"><span class="cl">                    f3:ac:24:6d:71:d6:44:7a:97:7a:10:e0:5b:2e:1c:
</span></span><span class="line"><span class="cl">                    80:91:71:4c:45:e8:97:2c:5d:30:68:1c:2a:28:96:
</span></span><span class="line"><span class="cl">                    24:1a:a2:40:ad:d8:aa:9b:d8:3b:89:e4:eb:a0:77:
</span></span><span class="line"><span class="cl">                    a4:1f:ab:5f:7d:8e:82:37:1d:c5:f5:9d:d6:5a:19:
</span></span><span class="line"><span class="cl">                    ea:5e:57:35:f9:ba:63:66:f0:4c:48:97:22:8f:2f:
</span></span><span class="line"><span class="cl">                    bf:7f:51:fe:bf:20:01:3c:17:11:9d:82:01:7c:f5:
</span></span><span class="line"><span class="cl">                    31:04:c7:33:10:75:5c:2a:b0:ae:d1:12:fe:6e:b9:
</span></span><span class="line"><span class="cl">                    5b:cf:67:1e:78:b6:ae:87:70:65:f8:c6:88:c6:10:
</span></span><span class="line"><span class="cl">                    7c:58:f5:7e:15:8a:47:97:9c:e1:68:7b:ed:7c:db:
</span></span><span class="line"><span class="cl">                    e5:6a:de:c1:4b:a1:05:6d:da:1e:bf:44:f9:05:6b:
</span></span><span class="line"><span class="cl">                    bb:c3:41:f3:f5:a8:39:7a:2b:eb:ac:d9:61:30:bf:
</span></span><span class="line"><span class="cl">                    0d:56:54:f8:39:b9:fc:01:93:5a:1d:aa:bf:2f:c8:
</span></span><span class="line"><span class="cl">                    30:97
</span></span><span class="line"><span class="cl">                Exponent: 65537 (0x10001)
</span></span><span class="line"><span class="cl">        X509v3 extensions:
</span></span><span class="line"><span class="cl">            X509v3 Subject Key Identifier: 
</span></span><span class="line"><span class="cl">                CB:3C:17:D8:D4:F1:C2:7C:00:57:46:48:1F:9B:A2:4F:DA:9A:92:66
</span></span><span class="line"><span class="cl">            X509v3 Authority Key Identifier: 
</span></span><span class="line"><span class="cl">                keyid:CB:3C:17:D8:D4:F1:C2:7C:00:57:46:48:1F:9B:A2:4F:DA:9A:92:66
</span></span><span class="line"><span class="cl">                DirName:/C=CN/ST=ChengDu/L=ChengDu/O=HRX/OU=HRX/CN=HRX/emailAddress=comedshang@163.com
</span></span><span class="line"><span class="cl">                serial:9F:56:FD:F5:9D:13:2E:D2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 Basic Constraints: 
</span></span><span class="line"><span class="cl">                CA:TRUE
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha1WithRSAEncryption
</span></span><span class="line"><span class="cl">        b1:6e:10:48:3c:4b:d1:4d:6e:5c:14:34:79:89:e0:95:3e:48:
</span></span><span class="line"><span class="cl">        3d:53:6c:65:64:ce:90:e2:da:17:2f:e2:8e:13:6a:1c:e2:d8:
</span></span><span class="line"><span class="cl">        b9:4c:f2:24:19:60:64:ae:66:cb:e6:82:de:a5:22:40:8e:50:
</span></span><span class="line"><span class="cl">        94:4c:5f:87:6e:f6:c4:be:ff:3b:75:eb:3a:f5:eb:aa:47:c4:
</span></span><span class="line"><span class="cl">        5c:14:d9:7d:38:ee:28:8c:96:8f:22:a1:85:63:a9:e3:23:d2:
</span></span><span class="line"><span class="cl">        64:fe:50:dd:ab:4e:53:f6:f7:67:c1:ec:39:89:20:04:f1:3f:
</span></span><span class="line"><span class="cl">        f1:18:5a:ab:77:eb:02:d3:93:34:ca:e8:81:6b:6f:60:5c:9d:
</span></span><span class="line"><span class="cl">        b7:1f:e9:be:cb:9a:b2:73:47:52:d7:d6:89:ce:34:4c:46:3c:
</span></span><span class="line"><span class="cl">        c3:73:9f:93:07:72:41:d4:64:f9:f1:52:56:78:ac:96:fe:da:
</span></span><span class="line"><span class="cl">        b5:c0:b3:8f:e0:5e:8c:a3:bf:21:d7:99:27:ff:65:e4:62:8c:
</span></span><span class="line"><span class="cl">        15:14:8f:bb:04:54:30:4e:5e:32:a8:8c:ab:70:27:14:99:5e:
</span></span><span class="line"><span class="cl">        9b:11:dc:0a:e8:d4:59:8b:98:de:30:b3:5e:f2:8c:e4:b3:2b:
</span></span><span class="line"><span class="cl">        62:07:9a:74:52:c0:e3:54:4c:86:4b:cd:88:f3:6b:1a:c8:66:
</span></span><span class="line"><span class="cl">        d6:ab:1d:c5:12:e2:66:0a:01:a8:3d:0c:f8:d4:ac:1d:74:80:
</span></span><span class="line"><span class="cl">        83:06:3f:6d
</span></span></code></pre></td></tr></table>
</div>
</div><p>备注，要参看其它证书类型的内容，参考 <a
  href="https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs#view-certificates"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs#view-certificates</a></p>
<p>一些特性，</p>
<ul>
<li>首先，我们可以看到不像 𝐶𝐴CA 证书那样有多层证书结构，自签名证书只有一层证书结构；也就是没有 Certificate Chain 的概念；</li>
<li>再次，可以看到 <em>Issuer</em> 发布者和证书拥有者 <em>Subject</em> 是相同的，都是 <em>C=CN, ST=ChengDu, L=ChengDu, O=HRX, OU=HRX, <a
  href="mailto:CN=HRX/emailAddress=comedshang@163.com"
  
  
  
  
  
>CN=HRX/emailAddress=comedshang@163.com</a></em>，表明证书的签名方和证书自己是同一个机构(或者角色)，这也就是<code>自签名</code>命名的由来；</li>
</ul>
<p>关键内容，</p>
<ul>
<li>Subject Public Key Info
这段内容就是公钥的内容了；</li>
<li>Signature Algorithm: sha1WithRSAEncryption
这段内容就表示对公钥和身份信息一起的签名信息了，可以看到，采用的是 𝑆𝐻𝐴1SHA1 算法；</li>
</ul>
<p>最后，比较重要的是，因为该证书只有一层，所以，自签名证书在通讯过程中扮演的也就是 Root Certificate，通常是需要被加载如客户端的 trust store 中；</p>
<h1 id="如何保证内网通讯的安全性">如何保证内网通讯的安全性</h1>
<p>比如内网中，Alice 想和 Bob 保持可靠的加密通讯；</p>
<ul>
<li>
<p>首先，Alice 需要生成秘钥 𝐾𝑝Kp 以及自签名证书 𝐶𝑠𝑒𝑙𝑓Cself</p>
</li>
<li>
<p>然后，Bob 通过某种方式将 Alice 的 𝐶𝑠𝑒𝑙𝑓Cself 加入自己的 trust store 中；
注意，如果 Bob 是通过浏览器访问的 Alice 站点，那么浏览器会提示，是否相信该证书，如果选择相信，这个时候，浏览器会自动将该 𝐶𝑠𝑒𝑙𝑓Cself 证书加入自己的 trust store 中；</p>
</li>
<li>
<p>之后，某个时刻，Bob 向 Alice 发起安全通讯的会话，双方握手过程中，</p>
</li>
<li>
<p>Alice 将 𝐶′𝑠𝑒𝑙𝑓Cself′ (X.509 自签名)证书发送给 Bob</p>
</li>
<li>
<p>Bob 通过 trust store 中之前预加载的 𝐶𝑠𝑒𝑙𝑓Cself 中所指明的签名算法对 𝐶′𝑠𝑒𝑙𝑓Cself′ 进行签名，得到签名 𝑆′S′</p>
</li>
<li>
<p>最后 Bob 使用 trust store 中 𝐶𝑠𝑒𝑙𝑓Cself 的签名 𝑆S 与 𝑆′S′ 进行比较，</p>
</li>
<li>
<p>若相等，则表示 Alice 当前发送过来的证书是可靠的，也就是说，其身份信息和公钥是合法的，没有被伪造过；</p>
</li>
<li>
<p>若不等，则表示 Alice 当前发送过来的证书是不可靠的，其身份信息或者是公钥是被篡改过的；应当立即停止与 Alice 的通讯；这种情况下，往往会提示握手失败，证书不可靠；</p>
</li>
</ul>
<p>但切记，在公网中使用自签名证书的 SSL 加密通讯的方式是不可靠的，其根本原因是，因为没有公钥基础设施的支持，其自签名证书很容易被伪造；这部分内容在之前的 <a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施</a> 等系列文章中有过详细的阐述，有兴趣的读者可以从这里开始；</p>
<h1 id="如何加入-trust-store">如何加入 trust store</h1>
<p>参考如下的几篇文章，</p>
<p>openssl with Apache:</p>
<p><a
  href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-apache-in-ubuntu-16-04"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>How To Create a Self-Signed SSL Certificate for Apache in Ubuntu 16.04</a></p>
<p><a
  href="https://www.akadia.com/services/ssh_test_certificate.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>How to create a self-signed SSL Certificate for Apache</a></p>
<p>java keytool series:</p>
<dl>
<dt>Tomcat SSL Installation Instructions</dt>
<dd><a
  href="https://www.sslshopper.com/tomcat-ssl-installation-instructions.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://www.sslshopper.com/tomcat-ssl-installation-instructions.html</a></dd>
</dl>
<p>java keytool - Key and Certificate Management Tool: <a
  href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/solaris/keytool.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://docs.oracle.com/javase/1.5.0/docs/tooldocs/solaris/keytool.html</a></p>
<p>Import a private key into a Java Key Store: <a
  href="http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art049"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art049</a></p>
]]></description>
</item><item>
  <title>RSA(六) X.509 CA 证书</title>
  <link>https://ronin-zc.com/rsa%E5%85%AD-x.509-ca-%E8%AF%81%E4%B9%A6/</link>
  <pubDate>Wed, 03 Mar 2021 13:46:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E5%85%AD-x.509-ca-%E8%AF%81%E4%B9%A6/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>由前文 <a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施</a>可知，CA 证书授权中心颁发给用户的是一张 <em>X.509 证书</em>；本篇文章，博主将带领大家一探 <em>X.509 证书</em>的究竟；</p>
<p>重要：本文为作者的原创作品，转载需注明出处；</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/27/encrypt-rsa-selfsigned-certificate/</code></p>
</blockquote>
<h1 id="通过-csr-申请-x509-ca-证书">通过 CSR 申请 X509 CA 证书</h1>
<p>这里大致讲解如何申请 <em>X.509 CA</em> 证书的流程，</p>
<ol>
<li>用户先在本地通过 RSA 生成一对公钥 𝐾𝑝Kp 和密钥 𝐾𝑠Ks，</li>
<li>然后，用户在本地生成一张 𝐶𝑆𝑅CSR 证书，既 <a
  href="https://en.wikipedia.org/wiki/Certificate_signing_request"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Certificate Signing Request</a>
<ul>
<li>需要填写诸如你的域名，公司名，部门名称，城市名，地区名，国家名，电子邮件等等证明你身份的信息，</li>
<li>添加用户公钥 𝐾𝑝</li>
<li>将上述信息通过 𝐾𝑠 进行签名得到 𝑆𝑐𝑠𝑟</li>
<li>将上述的签名 𝑆𝑐𝑠𝑟、𝐾𝑝 以及身份信息合并成为一张 𝐶𝑆𝑅 证书 ;
TODO: 需要合并 𝑆𝑐𝑠𝑟 吗？这个还需要进一步求证……</li>
</ul>
</li>
<li>申请者通过向 CA 中心或者 RA 中心提交 𝐶𝑆𝑅 证书，申请 <em>X.509 证书</em>；</li>
<li>𝐶𝐴 中心用它的密钥 𝐾𝑠(𝑐𝑎)Ks(ca) 对用户提交的 𝐶𝑆𝑅 证书进行签名，将签名和 𝐶𝑆𝑅 合并生成一张 <em>X.509 证书</em>；详细的签名过程，
<ul>
<li>𝐶𝐴 中心通过签名算法(比如 MD5)对 𝐶𝑆𝑅 证书进行签名；</li>
<li>然后通过 𝐾𝑠(𝑐𝑎)) 对上述的签名进行加密，得到加密后的签名；</li>
<li>最后，将加密后的签名和用户提交的 𝐶𝑆𝑅合并成为一张 <em>X.509 证书</em>；</li>
</ul>
</li>
<li>最后将该 <em>X.509 证书</em> 颁发给用户；</li>
</ol>
<p>备注，如何生成 CSR 证书可以参考 <a
  href="https://www.sslshopper.com/article-most-common-openssl-commands.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://www.sslshopper.com/article-most-common-openssl-commands.html</a></p>
<h1 id="证书链-certificate-chain">证书链 Certificate Chain</h1>
<h2 id="什么是证书链">什么是证书链</h2>
<p><em>X.509 证书</em> 中往往不止一张证书，而是由一系列的证书所组成的证书链，通常包含这样三层证书所构成的证书链，</p>
<p></p>
<ol>
<li>root certificate，根证书</li>
<li>intermediates certificates，一系列中间证书</li>
<li>end-user certificate，终端用户证书</li>
</ol>
<p>相信大部分读者会和我一样，迷惑，为什么一张 <em>X.509</em> 证书要搞得这么复杂？</p>
<p>这样做其实是有历史原因的，那是因为随系统和浏览器预安装的根证书毕竟是有限的，往往就那么些，一旦系统已经发布，大部分用户也已经安装好了，Root Certificate 既根证书就没有办法再通过预安装的方式来进行扩充了；但是我们知道，会有日新月异的新的 CA 公司成立，并被允许授权颁发 <em>X.509</em> 证书，毕竟，我们要允许市场的充分竞争，那么它们的公钥如何预安装到客户端的浏览器和操作系统上呢？如果不能预安装，由前文<a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%85%ac%e9%92%a5%e4%b8%8d%e8%a2%ab%e7%af%a1%e6%94%b9%e7%9a%84"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>如何保证公钥不被篡改的</a>分析可知，它们所颁发的证书是不可靠的，是可以被篡改的；那么如何调和这个矛盾呢？该怎么办呢？</p>
<p>于是，intermediates certificates 中间证书就出现了，这些证书就是表示由 Root Certificate 证书所签名认证的证书，这样，新的 CA 公司所颁发的证书可以由 Root Certificate 进行认证，保证其合法性和可靠性，这样就充分允许了新的 CA 公司成立并参与 CA 这块市场的竞争了；</p>
<p>下面，就用这么一个形象的例子来描述，比如，有一天，中国成立了一家 ShangYang 公司，该公司的主营业务就是为广大客户进行证书授权，参与 CA 领域的商业竞争；那么这个时候呢，我需要向掌管 Root Certificate 的机构提交申请，请它签名我的 CA 公钥 (说好的市场充分竞争呢？Root Certificate 机构不就是赤裸裸的垄断机构？谁知道呢..)，生成一张 intermediates certificate 中间证书；这样，由 ShangYang 公司所签名的证书就得到了 Root Certificate 的认证，那么由该公司所颁发的 <em>X.509</em> 证书就是合法，正规的了；</p>
<p>由此，我们也能够大致知道整个证书链的验证过程了，证书链的验证过程将会在后续<a
  href="/images/RSA/#%e8%af%81%e4%b9%a6%e9%93%be%e7%9a%84%e9%aa%8c%e8%af%81%e8%bf%87%e7%a8%8b"
  
  
  
  
  
>证书链的验证过程</a>进行详细的描述；</p>
<p>总结一下，</p>
<p>根证书是被预装到客户端电脑或者用户其它终端设备上的(比如手机)，它的作用主要是验证 CA 证书签名的合法性，也就是保证 CA 的证书(含 CA 的公钥)的合法性；最后，end-user certificate 终端用户证书，该证书由 CA 的证书保证其合法性；所以，可以看到，各个证书的验证过程是一环扣一环的，根证书验证 CA 证书的合法性，CA 证书验证用户证书的合法性；</p>
<h2 id="证书链中每个证书所包含的内容">证书链中每个证书所包含的内容</h2>
<p>我们来看看 wikipedia.org 的 <em>X.509</em> 证书的情况，他是由 GlobalSign 机构颁发的，</p>
<h3 id="end-user或-end-entity-certificate-既终端用户证书">End-user(或 End-entity) certificate 既终端用户证书</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Certificate:
</span></span><span class="line"><span class="cl">    Data:
</span></span><span class="line"><span class="cl">        Version: 3 (0x2)
</span></span><span class="line"><span class="cl">        Serial Number:
</span></span><span class="line"><span class="cl">            10:e6:fc:62:b7:41:8a:d5:00:5e:45:b6
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha256WithRSAEncryption
</span></span><span class="line"><span class="cl">        Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2
</span></span><span class="line"><span class="cl">        Validity
</span></span><span class="line"><span class="cl">            Not Before: Nov 21 08:00:00 2016 GMT
</span></span><span class="line"><span class="cl">            Not After : Nov 22 07:59:59 2017 GMT
</span></span><span class="line"><span class="cl">        Subject: C=US, ST=California, L=San Francisco, O=Wikimedia Foundation, Inc., CN=*.wikipedia.org
</span></span><span class="line"><span class="cl">        Subject Public Key Info:
</span></span><span class="line"><span class="cl">            Public Key Algorithm: id-ecPublicKey
</span></span><span class="line"><span class="cl">                Public-Key: (256 bit)
</span></span><span class="line"><span class="cl">                pub: 
</span></span><span class="line"><span class="cl">                    04:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5:
</span></span><span class="line"><span class="cl">                    af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e:
</span></span><span class="line"><span class="cl">                    ed:b2:ac:2a:1b:4a:ec:80:7b:e7:1a:51:e0:df:f7:
</span></span><span class="line"><span class="cl">                    c7:4a:20:7b:91:4b:20:07:21:ce:cf:68:65:8c:c6:
</span></span><span class="line"><span class="cl">                    9d:3b:ef:d5:c1
</span></span><span class="line"><span class="cl">                ASN1 OID: prime256v1
</span></span><span class="line"><span class="cl">                NIST CURVE: P-256
</span></span><span class="line"><span class="cl">        X509v3 extensions:
</span></span><span class="line"><span class="cl">            X509v3 Key Usage: critical
</span></span><span class="line"><span class="cl">                Digital Signature, Key Agreement
</span></span><span class="line"><span class="cl">            Authority Information Access: 
</span></span><span class="line"><span class="cl">                CA Issuers - URI:http://secure.globalsign.com/cacert/gsorganizationvalsha2g2r1.crt
</span></span><span class="line"><span class="cl">                OCSP - URI:http://ocsp2.globalsign.com/gsorganizationvalsha2g2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 Certificate Policies: 
</span></span><span class="line"><span class="cl">                Policy: 1.3.6.1.4.1.4146.1.20
</span></span><span class="line"><span class="cl">                  CPS: https://www.globalsign.com/repository/
</span></span><span class="line"><span class="cl">                Policy: 2.23.140.1.2.2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 Basic Constraints: 
</span></span><span class="line"><span class="cl">                CA:FALSE
</span></span><span class="line"><span class="cl">            X509v3 CRL Distribution Points: 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                Full Name:
</span></span><span class="line"><span class="cl">                  URI:http://crl.globalsign.com/gs/gsorganizationvalsha2g2.crl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 Subject Alternative Name: 
</span></span><span class="line"><span class="cl">                DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org
</span></span><span class="line"><span class="cl">            X509v3 Extended Key Usage: 
</span></span><span class="line"><span class="cl">                TLS Web Server Authentication, TLS Web Client Authentication
</span></span><span class="line"><span class="cl">            X509v3 Subject Key Identifier: 
</span></span><span class="line"><span class="cl">                28:2A:26:2A:57:8B:3B:CE:B4:D6:AB:54:EF:D7:38:21:2C:49:5C:36
</span></span><span class="line"><span class="cl">            X509v3 Authority Key Identifier: 
</span></span><span class="line"><span class="cl">                keyid:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha256WithRSAEncryption
</span></span><span class="line"><span class="cl">         8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35:
</span></span><span class="line"><span class="cl">         ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这张证书就是 wikipedia.org 的终端用户证书了，看看几个关键的属性</p>
<ol>
<li>
<p>Subject</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Subject: C=US, ST=California, L=San Francisco, O=Wikimedia Foundation, Inc., CN=*.wikipedia.org
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到该证书的主体结构，表示该证书的主体机构是 wikipedia.org，以及相关的一些附属信息，比如国家，地域，公司名称等等；</p>
</li>
<li>
<p>Subject Alternative Name
表述了该证书还可以用在哪些域名上，这里定义了好些其它的可用域名的验证上，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X509v3 Subject Alternative Name: 
</span></span><span class="line"><span class="cl">  DNS:*.wikipedia.org, DNS:*.m.mediawiki.org, DNS:*.m.wikibooks.org, DNS:*.m.wikidata.org, DNS:*.m.wikimedia.org, DNS:*.m.wikimediafoundation.org, DNS:*.m.wikinews.org, DNS:*.m.wikipedia.org, DNS:*.m.wikiquote.org, DNS:*.m.wikisource.org, DNS:*.m.wikiversity.org, DNS:*.m.wikivoyage.org, DNS:*.m.wiktionary.org, DNS:*.mediawiki.org, DNS:*.planet.wikimedia.org, DNS:*.wikibooks.org, DNS:*.wikidata.org, DNS:*.wikimedia.org, DNS:*.wikimediafoundation.org, DNS:*.wikinews.org, DNS:*.wikiquote.org, DNS:*.wikisource.org, DNS:*.wikiversity.org, DNS:*.wikivoyage.org, DNS:*.wiktionary.org, DNS:*.wmfusercontent.org, DNS:*.zero.wikipedia.org, DNS:mediawiki.org, DNS:w.wiki, DNS:wikibooks.org, DNS:wikidata.org, DNS:wikimedia.org, DNS:wikimediafoundation.org, DNS:wikinews.org, DNS:wikiquote.org, DNS:wikisource.org, DNS:wikiversity.org, DNS:wikivoyage.org, DNS:wiktionary.org, DNS:wmfusercontent.org, DNS:wikipedia.org
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Subject Public Key</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Subject Public Key Info:
</span></span><span class="line"><span class="cl">    Public Key Algorithm: id-ecPublicKey
</span></span><span class="line"><span class="cl">        Public-Key: (256 bit)
</span></span><span class="line"><span class="cl">        pub: 
</span></span><span class="line"><span class="cl">            04:c9:22:69:31:8a:d6:6c:ea:da:c3:7f:2c:ac:a5:
</span></span><span class="line"><span class="cl">            af:c0:02:ea:81:cb:65:b9:fd:0c:6d:46:5b:c9:1e:
</span></span><span class="line"><span class="cl">            ed:b2:ac:2a:1b:4a:ec:80:7b:e7:1a:51:e0:df:f7:
</span></span><span class="line"><span class="cl">            c7:4a:20:7b:91:4b:20:07:21:ce:cf:68:65:8c:c6:
</span></span><span class="line"><span class="cl">            9d:3b:ef:d5:c1
</span></span><span class="line"><span class="cl">        ASN1 OID: prime256v1
</span></span><span class="line"><span class="cl">        NIST CURVE: P-256
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就是终端用户的公钥信息了，注意，这里的公钥并不是采用的 RSA 算法，而是采用的 DSA 算法，具体可参考 <a
  href="https://en.wikipedia.org/wiki/ECDSA"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>ECDSA</a>；</p>
</li>
<li>
<p>Signature Algorithm
这部分内容表示所用的签名算法以及被 CA 中心签名后的内容，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Signature Algorithm: sha256WithRSAEncryption
</span></span><span class="line"><span class="cl">    8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35:
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，该签名算法是采用的 SHA256 算法，并通过 RSA 加密(这里是通过 CA 的私钥加密)，所以这里得到的其实是被 CA 私钥加密后的 SHA 签名；后面对应 <em>8b:c3:ed:d1:9d:39:6f:af:40:72:bd:1e:18:5e:30:54:23:35:</em> 就是该加密后的签名；</p>
</li>
</ol>
<p>从前面的系列文章 <a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施</a>我们知道，终端用户公钥签名是需要被相关的 CA 证书验证的(既是通过 CA 的公钥进行解密验证)；那么它是如何找到对应的 CA 证书并进行验证的呢？通过终端用户证书中的两个字段；</p>
<ol>
<li>
<p>Issuer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以明显的看到，该用户终端证书是由 <strong>GlobalSign</strong> 𝐶𝐴CA 中心进行验证并签发的。</p>
</li>
<li>
<p>Authority Key Identifier</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X509v3 Authority Key Identifier: 
</span></span><span class="line"><span class="cl">           keyid:96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
</span></span></code></pre></td></tr></table>
</div>
</div><p>𝐶𝐴中心的身份 𝐼𝐷</p>
</li>
</ol>
<p>那顾名思义，终端用户证书将会找到与 <em>Issuer</em> 和 <em>Authority Key Identifier</em> 两者都匹配的 𝐶𝐴 证书来对它进行验证；好了，接下来，我们看看 𝐶𝐴 证书长什么样，也就是 <em>Intermediate certificate</em>；</p>
<h3 id="intermediate-certificate-既-ca-证书">Intermediate certificate 既 CA 证书</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Certificate:
</span></span><span class="line"><span class="cl">    Data:
</span></span><span class="line"><span class="cl">        Version: 3 (0x2)
</span></span><span class="line"><span class="cl">        Serial Number:
</span></span><span class="line"><span class="cl">            04:00:00:00:00:01:44:4e:f0:42:47
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha256WithRSAEncryption
</span></span><span class="line"><span class="cl">        Issuer: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
</span></span><span class="line"><span class="cl">        Validity
</span></span><span class="line"><span class="cl">            Not Before: Feb 20 10:00:00 2014 GMT
</span></span><span class="line"><span class="cl">            Not After : Feb 20 10:00:00 2024 GMT
</span></span><span class="line"><span class="cl">        Subject: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2
</span></span><span class="line"><span class="cl">        Subject Public Key Info:
</span></span><span class="line"><span class="cl">            Public Key Algorithm: rsaEncryption
</span></span><span class="line"><span class="cl">                Public-Key: (2048 bit)
</span></span><span class="line"><span class="cl">                Modulus:
</span></span><span class="line"><span class="cl">                    00:c7:0e:6c:3f:23:93:7f:cc:70:a5:9d:20:c3:0e:
</span></span><span class="line"><span class="cl">                    ...
</span></span><span class="line"><span class="cl">                Exponent: 65537 (0x10001)
</span></span><span class="line"><span class="cl">        X509v3 extensions:
</span></span><span class="line"><span class="cl">            X509v3 Key Usage: critical
</span></span><span class="line"><span class="cl">                Certificate Sign, CRL Sign
</span></span><span class="line"><span class="cl">            X509v3 Basic Constraints: critical
</span></span><span class="line"><span class="cl">                CA:TRUE, pathlen:0
</span></span><span class="line"><span class="cl">            X509v3 Subject Key Identifier:
</span></span><span class="line"><span class="cl">                96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
</span></span><span class="line"><span class="cl">            X509v3 Certificate Policies:
</span></span><span class="line"><span class="cl">                Policy: X509v3 Any Policy
</span></span><span class="line"><span class="cl">                  CPS: https://www.globalsign.com/repository/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 CRL Distribution Points:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                Full Name:
</span></span><span class="line"><span class="cl">                  URI:http://crl.globalsign.net/root.crl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            Authority Information Access:
</span></span><span class="line"><span class="cl">                OCSP - URI:http://ocsp.globalsign.com/rootr1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            X509v3 Authority Key Identifier:
</span></span><span class="line"><span class="cl">                keyid:60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha256WithRSAEncryption
</span></span><span class="line"><span class="cl">         46:2a:ee:5e:bd:ae:01:60:37:31:11:86:71:74:b6:46:49:c8:
</span></span><span class="line"><span class="cl">         ...
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>Intermidate certificate</em> 既是 𝐶𝐴 证书，是用来验证用户终端证书(既 <em>End-entity certificate</em>)的；通过两个字段来匹配用户终端证书，</p>
<ul>
<li>
<p>𝐶𝐴 证书中的 <em>Issuer</em> 和用户终端证书中的 <em>Issuer</em> 相匹配</p>
</li>
<li></li>
</ul>
<p>𝐶𝐴</p>
<p>证书中的</p>
<p>Subject Key Identifier</p>
<p>与用户终端证书中的</p>
<p>Authority Key Identifier</p>
<p>相匹配；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X509v3 Subject Key Identifier:
</span></span><span class="line"><span class="cl">              96:DE:61:F1:BD:1C:16:29:53:1C:C0:CC:7D:3B:83:00:40:E6:1A:7C
</span></span></code></pre></td></tr></table>
</div>
</div><p>与 𝐶𝐴 证书相匹配的用户终端证书将会被该 𝐶𝐴 证书所验证；</p>
<h3 id="root-certificate-既根证书">Root Certificate 既根证书</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Certificate:
</span></span><span class="line"><span class="cl">    Data:
</span></span><span class="line"><span class="cl">        Version: 3 (0x2)
</span></span><span class="line"><span class="cl">        Serial Number:
</span></span><span class="line"><span class="cl">            04:00:00:00:00:01:15:4b:5a:c3:94
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha1WithRSAEncryption
</span></span><span class="line"><span class="cl">        Issuer: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
</span></span><span class="line"><span class="cl">        Validity
</span></span><span class="line"><span class="cl">            Not Before: Sep  1 12:00:00 1998 GMT
</span></span><span class="line"><span class="cl">            Not After : Jan 28 12:00:00 2028 GMT
</span></span><span class="line"><span class="cl">        Subject: C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
</span></span><span class="line"><span class="cl">        Subject Public Key Info:
</span></span><span class="line"><span class="cl">            Public Key Algorithm: rsaEncryption
</span></span><span class="line"><span class="cl">                Public-Key: (2048 bit)
</span></span><span class="line"><span class="cl">                Modulus:
</span></span><span class="line"><span class="cl">                    00:da:0e:e6:99:8d:ce:a3:e3:4f:8a:7e:fb:f1:8b:
</span></span><span class="line"><span class="cl">                    ...
</span></span><span class="line"><span class="cl">                Exponent: 65537 (0x10001)
</span></span><span class="line"><span class="cl">        X509v3 extensions:
</span></span><span class="line"><span class="cl">            X509v3 Key Usage: critical
</span></span><span class="line"><span class="cl">                Certificate Sign, CRL Sign
</span></span><span class="line"><span class="cl">            X509v3 Basic Constraints: critical
</span></span><span class="line"><span class="cl">                CA:TRUE
</span></span><span class="line"><span class="cl">            X509v3 Subject Key Identifier: 
</span></span><span class="line"><span class="cl">                60:7B:66:1A:45:0D:97:CA:89:50:2F:7D:04:CD:34:A8:FF:FC:FD:4B
</span></span><span class="line"><span class="cl">    Signature Algorithm: sha1WithRSAEncryption
</span></span><span class="line"><span class="cl">         d6:73:e7:7c:4f:76:d0:8d:bf:ec:ba:a2:be:34:c5:28:32:b5:
</span></span><span class="line"><span class="cl">         ...
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>Intermediate certificate</em> 既是 𝐶𝐴 证书将会被 <em>Root certificate</em> 进行验证，并且 <em>Root certificate</em> 是证书验证链中的最后一环，所以的验证将会到此为止；那么 𝐶𝐴 证书又是如何找到对应的 <em>Root certificate</em> 进行验证的呢？主要通过如下的规则进行匹配</p>
<ol>
<li>𝐶𝐴 证书中的 <em>Issuer</em> 需要与 <em>Root certificate</em> 中的 <em>Issuer</em> 匹配</li>
<li>𝐶𝐴 证书中的 <em>Authority Key Identifier</em> 字段需要与 <em>Root certificate</em> 证书中的 <em>Subject Key Identifier</em> 字段相匹配</li>
</ol>
<p>这样，与之匹配的 𝐶𝐴 证书将会由该 <em>Root certificate</em> 证书进行验证；</p>
<p>最后，需要强调的是，𝐶𝐴 证书并不会随浏览器和系统的安装而预安装到用户的设备上，<code>被预安装到用户设备上的只有 Root certificate</code>；这样呢，就保证了终端用户的公钥的可靠性和安全性；另外，通过 <em>Root certificate</em> 会被安装到系统的 <a
  href="https://en.wikipedia.org/wiki/Public_key_certificate#Root_programs"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>trust store</a>中，主流的有</p>
<ul>
<li><a
  href="https://technet.microsoft.com/en-us/library/cc751157.aspx"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Microsoft Root Program</a></li>
<li><a
  href="https://www.apple.com/certificateauthority/ca_program.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Apple Root Program</a></li>
<li><a
  href="https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Mozilla Root Program</a></li>
<li><a
  href="http://www.oracle.com/technetwork/java/javase/javasecarootcertsprogram-1876540.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Oracle Java root program</a></li>
<li>Adobe <a
  href="https://helpx.adobe.com/acrobat/kb/approved-trust-list2.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>AATL</a> and <a
  href="https://blogs.adobe.com/documentcloud/eu-trusted-list-now-available-in-adobe-acrobat/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>EUTL</a> root programs (used for document signing)</li>
</ul>
<p>后续有时间的话，准备对 Java 的 trust store 进行一下梳理和介绍；</p>
<h2 id="证书链的验证过程">证书链的验证过程</h2>
<p>有了上述分析以后，证书链的验证过程就显而易见了</p>
<ul>
<li>End-user certificate 通过 𝐶𝐴 证书进行验证</li>
<li>𝐶𝐴 证书经过 Root certificate 证书进行验证</li>
<li>完毕</li>
</ul>
<h1 id="实践">实践</h1>
<p>那么这里作者带领大家通过 CSR 的方式申请一个免费的 CA 证书，现在通过阿里云可以免费申请一个固定域名的 Symantec 的 CA 证书；</p>
<ol>
<li>
<p>登录阿里云产品中心，选择安全 -&gt; CA 证书</p>
</li>
<li>
<p>然后选择免费的 DV 类型的证书</p>
</li>
<li>
<p>购买好了以后，进入管理后台管理，进入安全（云盾）-&gt; 证书服务，然后对证书进行补全补全既是需要用户自己提交 CSR 申请证书；</p>
</li>
<li>
<p>填写域名信息，注意，这里只能绑定一个唯一的域名，且不能写任何的通配符</p>
</li>
<li>
<p>下一步将会填写一些个人信息，比如姓名、手机号码、地址等这里要强调的是，阿里云需要验证域名的归属，既验证该域名的确归你所有；可以通过 DNS 和 文件 的两种方式进行验证；这里呢，我选择的是通过 DNS 验证，验证的大致过程是，阿里会向你的申请邮箱中发送一份邮件，邮件的内容中包含了如何验证域名的方法，里面包含一条用于验证的 TXT 记录，这个需要到个人域名管理中心去配置 TXT 转发规则即可；</p>
</li>
<li>
<p>好了，这一步是关键了，这里有两个选项，由系统生成 CSR 或者自己生成 CSR，这里为了演示自提交 CSR 证书申请的方式，所以，我们选择自己生成 CSR</p>
</li>
<li>
<p>使用 openssl 命令生成 CSR</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl req -out CSR.csr -new -newkey rsa:2048 -nodes -keyout private.key
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后提示输入国家、地址、姓名、域名、邮箱等等信息；如果是为公司申请邮箱，那么这里填写公司相关信息即可；这里<code>尤其</code>要<code>注意</code>的是，在输入域名的时候，必须与第 4 步的域名相匹配，否则第 9 步审核不能通过，输入域名的时候，提示输入 <em>Common Name (e.g. server FQDN or YOUR name) []</em> 的信息；最后会在本地生成两个文件，CSR.csr 和 private.key</p>
</li>
<li>
<p>用文本编辑器打开 CSR.csr，可以看到大致内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN CERTIFICATE REQUEST-----
</span></span><span class="line"><span class="cl">MIIC3DCCAcQCAQAwgZYxCzAJBgNVBAYTAkNOMRAwDgYDVQQIEwdTaWNodWFuMRAw
</span></span><span class="line"><span class="cl">DgYDVQQHEwdDaGVuZ2R1MRQwEgYDVQQKEwtIdWlSb25nWGluZzEUMBIGA1UECxML
</span></span><span class="line"><span class="cl">SHVpUm9uZ1hpbmcxFDASBgNVBAMTC0h1aVJvbmdYaW5nMSEwHwYJKoZIhvcNAQkB
</span></span><span class="line"><span class="cl">FhJodWlyb25neGluZ0BocnguYWkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
</span></span><span class="line"><span class="cl">AoIBAQC7MY7hTjbv7DkGoDTmvQ2toAe8nMTlQGPh+r4VvD+zzEiEudFPEI1cIFLr
</span></span><span class="line"><span class="cl">BLTfSyn9Awv7lgIjhJ4ghDkjAGwHnrTxzvldjfZkpKuBK9H8Vy2t7sorgoxEBF7j
</span></span><span class="line"><span class="cl">VbiiTBtSG6+ZNw8esqt5EECT19aP/RyJp65f8lysHwcHmZmVGaDq/VwQcbyuI6Vs
</span></span><span class="line"><span class="cl">ko/7sSchOAgUWn66oS+xw7mGYR212mQv6Bz0g0L1NVep8Doz8O2pWPHT1ZOdpBDU
</span></span><span class="line"><span class="cl">rzJJxHXzUgKVgYsAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAQEA
</span></span><span class="line"><span class="cl">V6rSXeGO4Z0q2sZ9gbdUBmpQ8AAdloByhd1BcwHuHt/nfPj59L3CT3EnTEez7cDt
</span></span><span class="line"><span class="cl">RUCbI2FbThBFfjngfTNE3PjsTsheCdAxoV6yRPo7Fpb5AKkhXDra1jjVjsY0maFl
</span></span><span class="line"><span class="cl">N23okpDCMzmUD2peKqumYhdHBw8wB3Y5HZQxxq688DwlHn0bLnylUPk/hDfuMzIs
</span></span><span class="line"><span class="cl">5vLIyDSGQiCwq9sU8wjhQOXqzZ37FgJcZ8GyvaJ3kUWDlLDPIGMiXQ0p4T39/ZaE
</span></span><span class="line"><span class="cl">my/C0JxSLiAKJs3L2f7HfKwUoRZDDnCS0WMdQunvxC4Dd7hyddCij6E1ExnT7EzC
</span></span><span class="line"><span class="cl">kiPq8xiGl2HRGW/JfWC3XA==
</span></span><span class="line"><span class="cl">-----END CERTIFICATE REQUEST-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，是一个经过 Base64 编码的 PEM 格式的内容；</p>
</li>
<li>
<p>将上述内容复制，粘贴到阿里证书服务页面，点击保存注意第 7 步的描述，必须保证 CSR 中的域名地址与第 4 步申请的时候填写的域名地址相匹配才行；</p>
</li>
<li>
<p>验证域名的归属
由于第 5 步中，作者是选择的 DNS 验证的方式，所以，第 9 步完成以后，阿里会发送一封邮件包含需要验证的 TXT 记录值，这里只需要到域名管理中心配置一下 TXT 值，即可验证通过；域名管理中心配置好了以后，大致内容如下，不过，有时候，邮件迟迟不发送，这个时候，你可以直接点击<code>进度</code>按钮，也可以显示相关的 TXT 记录；</p>
</li>
<li>
<p>申请成功，当验证通过以后，状态便会变为<code>已签发</code>这个时候，你就可以在证书管理后台中去下载该 CA 证书了..</p>
</li>
</ol>
<p>All done…</p>
<p>后记于 2018-01-30 1:21 pm
阿里云上验证域名归属的步骤有变化，也就是上面的第 10 步，在添加主机记录的时候前面要加上 _dnsauth 前缀才行，如图

并且不再发邮件提示配置知己记录 TXT 值了；对应的域名配置如下，
</p>
<p>更多详情参考 <a
  href="https://bbs.aliyun.com/read/573056.html?spm=a2c4e.11155515.0.0.kL3FVf"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://bbs.aliyun.com/read/573056.html?spm=a2c4e.11155515.0.0.kL3FVf</a></p>
<h1 id="后续">后续</h1>
<p>这里主要讲解的是通过 𝐶𝐴 签名的证书，那如果，只是内网服务器，不需要连接外网，那么，实际上，我也就用不到这种公共的基础设施来保证我的证书的合法性；这个时候，X.509 证书还提供了一种自签名证书，什么意思呢？就是说，你可以自己生成 <em>Root certificate</em>，然后将它加入你本机的 trust store 中，用它来验证你的证书的合法性，这就是自签名证书了；详情参考</p>
]]></description>
</item><item>
  <title>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施</title>
  <link>https://ronin-zc.com/rsa%E4%BA%94-pki-public-key-infrastructure-%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/</link>
  <pubDate>Wed, 03 Mar 2021 13:45:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E4%BA%94-pki-public-key-infrastructure-%E5%85%AC%E9%92%A5%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>在上一篇《<a
  href="https://www.shangyang.me/2017/05/24/encrypt-rsa-signature/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(四) 签名 Signature</a>》章节<a
  href="https://www.shangyang.me/2017/05/24/encrypt-rsa-signature/#%e7%ad%be%e5%90%8d-Signature"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>签名 Signature</a> 中提到，要使用签名(Signature)机制来保证信息再传递过程中没有被第三方所篡改，有一个前提，就是必须保证，在公钥的传递过程中不被他人篡改，否则，整个签名机制就形同一张白纸，毫无用处；那么又该如何保证公钥的合法性，保证公钥本身没有被篡改过呢？这就是 PKI 公钥基础设施要完成的工作和达到的目的；</p>
<p>备注，本文是作者的原创作品，转载请注明出处。</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/</code></p>
</blockquote>
<h1 id="公钥被篡改">公钥被篡改</h1>
<p>首先，我们来看看，在通讯过程中，公钥是如何被他人所篡改的？也就是 Man in Middle Attack 是怎么做到的？</p>
<p>先来看一个正常的，通过公钥和私钥加密通讯的场景，</p>
<p></p>
<p>服务器端生成公钥和私钥，并将公钥通过网络发送给客户端，客户端使用公钥加密 DES 对称加密密钥，然后将 DES 密钥发送给服务器端，之后，双方便可以进行加密通讯了；备注，这也是基于 RSA 加密通讯的基础；但是，这样做，并不可靠，下面我们再来看一个公钥被挟持并被篡改的场景；</p>
<p></p>
<p>这次通讯的时候，不幸的是，客户端与服务器通讯的时候，正好经过了一个黑客的路由器，通过网络嗅探，它截获了服务器所发送的公钥，并利用自己的私钥，生成了一个新的公钥，并替代原有的公钥并将这个新的公钥发送给了客户端，这个过程就是公钥被截获，被篡改的过程；而后，客户端将使用被篡改过后的公钥进行加密通讯，所以，凡是经过客户端加密的信息，全部可以被黑客的私钥解密，也就导致了，加密通讯<code>彻底失效</code>；正是在这种背景之下，PKI (Public Key Infrasture) 公钥基础设施孕育而生；</p>
<p>后记，发现还漏了一环，首先要知道的是，当通过 RSA 建立好 SSL 通讯通道以后，实际上，为了效率，该通道上数据实际上是通过对称加密密钥 AES 进行加密传输的，所以，能否保证数据通讯的安全性的重中之重的环节就是保证 AES 密钥在传输过程中的安全性，正如上图所描述的那样，当黑客截获到加密后的 AES 密钥以后，首先需要通过黑客自己的私钥对其解密，然后再通过黑客所截获的服务器的公钥对该 AES 密钥进行加密，然后再传输给服务器端，如果不这样做的话，服务器是无法通过它自己的私钥解密出 AES 密钥的；（后记于 2018-01-30 10:45AM）</p>
<h1 id="pki">PKI</h1>
<p>PKI 的核心职责就是通过一些列的措施保证公钥的合法性，那么它是如何保证公钥不被篡改，是合法的呢？</p>
<h2 id="如何保证公钥不被篡改的">如何保证公钥不被篡改的</h2>
<p>比如 Alice 通过 RSA 生成了公钥 𝐾𝑝Kp 和密钥 𝐾𝑠Ks，她需要与 Bob 进行网络通讯，而且她必须通过网络将公钥 𝐾𝑝Kp 发送给 Bob；那么 PKI 是如何保证此公钥 𝐾𝑝Kp 在传输过程中不被篡改的呢？</p>
<p>简而言之，PKI 的策略就是通过一个第三方机构 𝑀M，该机构 𝑀M 也有自己的公钥 𝐾𝑝(𝑚)Kp(m) 和密钥 𝐾𝑠(𝑚)Ks(m)；</p>
<p><strong>首先通过该机构 𝑀M 进行如下的操作，</strong></p>
<ol>
<li>Alice 将自己的公钥 𝐾𝑝Kp 提交给 𝑀M；</li>
<li>𝑀M 使用签名算法，比如 MD5，对 Alice 的原生公钥 𝐾𝑝Kp 进行签名得到 𝑆𝑝Sp；</li>
<li>然后再通过 𝐾𝑠(𝑚)Ks(m) 对 𝑆𝑝Sp 进行加密得到加密后的签名 𝐸𝑠𝑝Esp；</li>
<li>最后将 𝐸𝑠𝑝Esp 颁发给 Alice；</li>
</ol>
<p><strong>Alice 如何将公钥发送给 Bob？</strong></p>
<ul>
<li>Alice 将加密后的签名 𝐸𝑠𝑝Esp 和公钥 𝐾𝑝Kp 一起发送给 Bob；
备注，其实签名 𝐸𝑠𝑝Esp 和公钥 𝐾𝑝Kp 被纳入一张<code>证书</code>(Certificate)中，Alice 发送给 Bob 的其实就是这么一张证书；但是，整整 X.509 证书包含的内容比这个复杂许多，不过概念上是等价的；这里，也就是证书的由来了。不仅要知其然，更要知其所以然..</li>
</ul>
<p><strong>Bob 如何保证接收到的 Alice 的公钥没有被篡改过？</strong></p>
<p>Bob 拿到 Alice 的证书以后，做如下操作，(为了区分，这里将传输过程中 Alice 的公钥命名为 𝐾′𝑝Kp′)</p>
<ol>
<li>通过 𝑀M 的公钥 𝐾𝑝(𝑚)Kp(m) 对 𝐸𝑠𝑝Esp 进行解密，得到 𝑆𝑝Sp；
注意，如果 𝐸𝑠𝑝Esp 被篡改了，这里是无法解密得到 𝑆𝑝Sp，也就是说，要保证解密成功，𝐸𝑠𝑝Esp 一定是没有被篡改过的；</li>
<li>然后使用双方所约定好的签名算法，比如 MD5，对 𝐾′𝑝Kp′ 进行签名，得到 𝑆′𝑝Sp′</li>
<li>最后比较 𝑆𝑝Sp 与 𝑆′𝑝Sp′ 是否相等，若相等，则表示发送过程中的公钥 𝐾′𝑝Kp′ 没有被篡改过，否则，则可以断言，𝐾′𝑝Kp′ 被篡改过，于是整个通讯不安全、不可靠；</li>
</ol>
<p>（备注，这里的机构 𝑀M 有个行业用语叫做 𝐶𝐴CA 既是 <em>Certification Authority</em>；）</p>
<p>等等，第三方机构 CA，在 Bob 端使用 CA 的公钥 𝐾𝑝(𝑐𝑎)Kp(ca) 对 𝐸𝑠𝑝Esp 进行解密，得到签名 𝑆𝑝Sp，那如果 CA 的公钥 𝐾𝑝(𝑐𝑎)Kp(ca) 在传输过程中也被篡改了呢？好问题，第三方机构 CA 自身如何保证其公钥的合法性？如果不能保证 CA 公钥的合法性，上述基于签名保证 Alice 公钥合法性的措施也就是是一纸空谈。</p>
<p><strong>那么，CA 又是如何保证自己的公钥的合法性的呢？</strong></p>
<p>这里将谈到的就是 KPI 的又一大特征，基础设施；</p>
<p>为了保证 CA 公钥的合法性，通常，CA 机构的公钥是随系统、浏览器等<code>预安装</code>到客户电脑上的，也就是说，你在装系统的时候，或者在安装浏览器的时候，CA 机构的公钥(一般是包含在 CA 证书中的) 被预装到了你的系统或者是浏览器中了；这样，黑客就没有办法通过网络拦截的办法去篡改 CA 机构的公钥了；这也就是<code>基础设施</code>命名的由来，既 <em>Infrastructure</em>；这样，也就保证了通过 CA 机构签名的证书即使是在不安全的网络环境中传播，依然是<code>可靠并且是有效的</code>；</p>
<h2 id="概念流程图">概念流程图</h2>
<p>真实过程中，用户是通过 𝐶𝑆𝑅CSR 证书向 𝐶𝐴CA 机构申请 𝑋.509X.509 证书，申请过程中会包含申请者的地址，单位，邮箱等信息，比下图要复杂；这里，主要是化繁为简，通过如下的概念图，将其核心逻辑阐述清楚，下面的逻辑流程图一一对应<a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%85%ac%e9%92%a5%e4%b8%8d%e8%a2%ab%e7%af%a1%e6%94%b9%e7%9a%84"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>如何保证公钥不被篡改的</a>中所描述的步骤；</p>
<p></p>
<p>注意两个关键步骤</p>
<ul>
<li><em>Step 6.1.1</em>: 断定签名 𝐸𝑠𝑝Esp 被篡改过；
要能够断定这种情况，保证 𝐸𝑠𝑝Esp 一定没有被篡改过，需要公钥基础设施(既 PKI )的保证，保证签名颁发机构 𝑀M 的公钥是无法被篡改的</li>
<li><em>Step 8.1</em>: 𝑆𝑝!=𝑆′𝑝Sp!=Sp′，则可以断定公钥是被篡改过得；
这里面更深层次的原因是，通过公钥认证机构得到的签名 𝑆𝑝Sp 与 Bob 自己得到的公钥签名 𝑆𝑝Sp 不匹配，则可断定，Alice 的公钥 𝐾𝑝Kp 被篡改过；</li>
</ul>
<h2 id="kpi-包含哪些元素">KPI 包含哪些元素</h2>
<p>在章节<a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%85%ac%e9%92%a5%e4%b8%8d%e8%a2%ab%e7%af%a1%e6%94%b9%e7%9a%84"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>如何保证公钥不被篡改的</a>中，作者用最通俗易懂的言语描述了 KPI 公钥基础设施是如何保证公钥的合法性的，以及其重要性；不过，在官方定义中，严格的定义了如下的角色，</p>
<ol>
<li>
<p>CA (Certificate Authority)，证书认证机构
对公钥、用户身份信息、域名等信息进行签名，生成相关的电子证书；并将电子证书颁发给申请用户；
另外还会通过其专有的协议来判断证书是否有效（是否超过使用有效期）,如果证书失效，将会生成证书回收列表既是 certificate revocation list ，该部分内容涉及到 Authority revocation lists 的相关内容，从 <a
  href="https://en.wikipedia.org/wiki/Certificate_authority"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/Certificate_authority</a> 摘要其核心内容如下，</p>
<blockquote>
<p>An authority revocation list (ARL) is a form of certificate revocation list (CRL) containing certificates issued to certificate authorities, contrary to CRLs which contain revoked end-entity certificates.</p>
</blockquote>
<p><a
  href="https://tools.ietf.org/html/rfc5280#section-4.1.2.6"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5280#section-4.1.2.6</a> 标注中也描述了有关 CRL 协议和标准；</p>
</li>
<li>
<p>RA (Registration Authority)，注册认证机构
看下 <a
  href="https://en.wikipedia.org/wiki/Public_key_infrastructure"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/Public_key_infrastructure</a> 中的描述，</p>
<blockquote>
<p>A registration authority which verifies the identity of entities requesting their digital certificates to be stored at the CA</p>
</blockquote>
<p>是用来验证证书申请机构的身份的；不过现在 CA 和 RA 并没有完全区分，往往两者表示同一个角色；
用户需要像该机构提交一张 CSR 格式的证书(该证书的后缀名为 <em>.csr</em>)，既是 <a
  href="https://en.wikipedia.org/wiki/Certificate_signing_request"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>certificate signing request</a> 来申请，里面需要填写诸如你的域名，公司名，部门名称，城市名，地区名，国家名，电子邮件等等证明你身份的信息；</p>
</li>
</ol>
<p>从 #1 中，我们知道，CA 不但会对用户的身份信息以及公钥进行签名，而且会生成相应的电子证书来保存这些签名信息，最终将该证书颁发给用户；而事实上，该电子证书经过数个版本的变化，现在已经形成了一个事实标准，那就是 <em>X.509 证书</em>；作者会在后续的文章中对其进行详细的介绍；</p>
<h3 id="ca-机构">CA 机构</h3>
<p>这里描述一下国际知名的 CA 机构有哪些，</p>
<p>如下内容可以从 <a
  href="https://en.wikipedia.org/wiki/Certificate_authority"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/Certificate_authority</a> 获得</p>
<p></p>
]]></description>
</item><item>
  <title>RSA(四) 签名 Signature</title>
  <link>https://ronin-zc.com/rsa%E5%9B%9B-%E7%AD%BE%E5%90%8D-signature/</link>
  <pubDate>Wed, 03 Mar 2021 13:44:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E5%9B%9B-%E7%AD%BE%E5%90%8D-signature/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>由<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(一) 背后的数学原理</a>可知，RSA 既公钥加密技术主要是通过私钥加密信息，然后由公钥来解密信息；但是，从 RSA 的数学原理中我们可以知道，其实私钥加密信息，然后用公钥来解密也是可以的；而因为公钥是公开的，私钥加密的东西谁都可以进行解密，那这样做有什么意义呢？本章节就是来探讨这样做的意义何在？一句话概括，它的意义就在于签名( sign )；</p>
<p>备注，本文是作者的原创作品，转载请注明出处。</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/24/encrypt-rsa-signature/</code></p>
</blockquote>
<h1 id="场景">场景</h1>
<p>来看这样一个场景，Bob 给股票经纪人 Alice 发送了一封邮件，让 Alice 帮他大量购买某支股票；可是刚买不久，股票就大跌，于是 Bob 转而否认发过那封邮件，声称那封邮件是伪造的；那么作为法官的你，如何来验证之前发送的那封邮件到底是不是 Bob 发送的呢？</p>
<p>要解决上述场景的问题，就需要使用到 RSA 签名技术了；</p>
<h1 id="签名-signature">签名 Signature</h1>
<p>为保证邮件是 Bob 发送的，在邮件收发协议上做了如下的操作约定，</p>
<ol>
<li>首先双方通过邮件协议约定好签名的算法，比如都是用 MD5 或者是其它签名算法。</li>
<li>Bob 在发送邮件的同时，邮件系统将做如下的操作
<ul>
<li>通过签名算法 MD5 将邮件内容<code>c</code>进行 <em>hash</em>，得到邮件内容的签名(Sign)，记为 𝑆1；</li>
<li>通过 Bob 的私钥 𝑃 对 𝑆1 进行加密，得到加密后邮件内容的签名(Encrypted Sign)，记为 𝑆1𝑒；</li>
<li>最后，Bob 通过邮箱系统将签名 𝑆1𝑒S1e，邮件内容<code>c</code>，以及 Bob 的公钥 𝑃 三部分内容发送给 Alice；
如何保证公钥的安全性和可靠性，不在本文涉及；</li>
</ul>
</li>
<li>Alice 收到 Bob 的邮件以后，邮箱系统会做如下的操作
<ul>
<li>使用 Bob 的公钥对 𝑆1𝑒 进行解密，得到 𝑆1；</li>
<li>使用双方事先约定好的签名算法 MD5 对<code>c</code>进行 <em>hash</em> 得到签名 𝑆2；</li>
<li>比较签名 𝑆1 和签名 𝑆2 是否相等
如果相等，则表示邮件内容没有被篡改；
如果不相等，则表示邮件内容被他人篡改；</li>
</ul>
</li>
</ol>
<p>不过，要保证信息的确没有被篡改，还有一条基本原则，就是 Bob 的公钥 𝑃 不能被篡改，如果公钥 𝑃 在 Bob 发送给 Alice 的过程被人篡改了，那么 Attacker 就可以自己杜撰一封邮件，并通过自己的私钥签名邮件，并将自己篡改后的公钥 𝑃𝑐Pc 一同发送给 Alice，那么这个时候，Alice 是没有办法确认邮件是否是被篡改过的；所以，用 RSA 签名的方式来保证信息没有被篡改过，一个基本的前提就是 Bob 的公钥 𝑃P 不能被第三方篡改；而要保证公钥不能被第三方篡改，就需要 PKI (Public Key Infrasture) 公钥基础设施来保证公钥的合法性，涉及到 CA，Root Certificate 根证书相关知识；这部分知识不打算在本文进行描述；相关内容参考 <a
  href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施</a>；</p>
<p>备注：Root Certificate 根证书就是 CA 证书认证机构用来签名验证公钥 𝑃 的；</p>
<h1 id="总结">总结</h1>
<p><a
  href="https://www.shangyang.me/2017/05/24/encrypt-rsa-signature/#%e7%ad%be%e5%90%8d-sign"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>签名 sign</a> 小节中详细的描述了 RSA 通过私钥签名的过程和作用；但是也知道，签名若要能起作用，必须借助 PKI 公钥基础设施来保证公钥的合法性；所以，可见，PKI 对于基于 RSA 的加密通讯协议起到至关重要的作用，没有它，一切基于 RSA 的加密通讯理论都白搭；后续章节，让我们来看看 PKI 是什么东西；</p>
]]></description>
</item><item>
  <title>RSA(三) 密钥的格式</title>
  <link>https://ronin-zc.com/rsa%E4%B8%89-%E5%AF%86%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F/</link>
  <pubDate>Wed, 03 Mar 2021 13:43:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E4%B8%89-%E5%AF%86%E9%92%A5%E7%9A%84%E6%A0%BC%E5%BC%8F/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>本篇博文重点描述密钥的种种格式；</p>
<p>备注，本文是作者的原创作品，转载请注明出处。</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/</code></p>
</blockquote>
<h1 id="pem-和-der">PEM 和 DER</h1>
<p>首先我们来看看什么是 PEM 和 DER</p>
<h2 id="什么是-der-格式">什么是 DER 格式</h2>
<p>DER 是密钥的二进制表述格式；</p>
<p><a
  href="http://fileformats.archiveteam.org/wiki/DER"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://fileformats.archiveteam.org/wiki/DER</a></p>
<blockquote>
<p><code>Distinguished Encoding Rules (DER)</code> is a <em>binary serialization</em> of ASN.1 format. It is often used for cryptographic data such as certificates, but has other uses.</p>
</blockquote>
<p>很明显，DER 就是 ASN.1 的二进制格式；</p>
<h2 id="什么是-pem-格式">什么是 PEM 格式</h2>
<p>PEM 格式既是对 DER 编码转码为 Base64 字符格式；通过解码，将会还原为 DER 格式；</p>
<p><a
  href="http://fileformats.archiveteam.org/wiki/PEM"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://fileformats.archiveteam.org/wiki/PEM</a></p>
<blockquote>
<p>A PEM file is plain text. It contain one or more objects, such as certificates or keys, which may not all be the same type. Each object is delimited by lines similar to “—–BEGIN …—–” and “—–END …—–”. Data that is not between such lines is ignored, and is sometimes used for comments, or for a human-readable dump of the encoded data.</p>
</blockquote>
<p>Following the “BEGIN” and “END” keywords is a name (such as “CERTIFICATE”) that can be used as an identifier for the type of object.</p>
<blockquote>
<p>The data between the delimiter lines starts with an optional email-like header section, followed by base64-encoded payload data. After decoding, the payload data is in DER format.</p>
</blockquote>
<p>总体而言，PEM 是明文格式，可以包含证书或者是密钥；其内容通常是以类似 “—–BEGIN …—–” 开头 “—–END …—–” 为结尾的这样的格式进行展示的；后续内容也描述到，PEM 格式的内容是 Base64 格式；通过解码，转换为 DER 格式，也就是说，PEM 是建立在 DER 编码之上的；</p>
<h2 id="总结">总结</h2>
<p>DER 实际上就是密钥的最原始的二进制格式；而 PEM 是对 DER 的 Base64 的编码，PEM 解码后得到的就是 DER 编码格式；</p>
<h1 id="格式">格式</h1>
<p>由于 DER 是二进制格式，不便于阅读和理解，一般而言，密钥都是通过 PEM 的格式进行存储的，所以，这部分内容主要是梳理出公钥和密钥以 PEM 编码存储的格式；</p>
<h2 id="公钥-pem-格式">公钥 PEM 格式</h2>
<h3 id="pkcs-1">PKCS #1</h3>
<p>PKCS #1 标准是专门为 RSA 密钥进行定义的，其对应的 PEM 文件格式如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN RSA PUBLIC KEY-----
</span></span><span class="line"><span class="cl">BASE64 ENCODED DATA
</span></span><span class="line"><span class="cl">-----END RSA PUBLIC KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的内容 <em>BASE64 ENCODED DATA</em> 指的就是 ANS.1 的 DER 的 Base64 编码，其内容类似于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChHmaw+WUhWrStdxWBcAR39i2e  
</span></span><span class="line"><span class="cl">3yz+vfLiDALeTpWIH1jKiYtvw4nMg6453pXAJSvPn7mKaiGiC3USIt8qTL4eCPi9  
</span></span><span class="line"><span class="cl">yNRDpZ1JRHI8M87VYB4c9KMk6IuVFiYyZ4MBTP87t89yeL9EOrAD0eFgi5fPx3g8  
</span></span><span class="line"><span class="cl">b9QrmnyPhMVjP7ct+wIDAQAB
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述内容翻译成 ASN.1 的格式为，此部分内容参考 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RSA-public-key-syntax-%e5%85%ac%e9%92%a5%e8%af%ad%e6%b3%95"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA public key syntax 公钥语法</a> 小节内容；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RSAPublicKey ::= SEQUENCE {
</span></span><span class="line"><span class="cl">    modulus           INTEGER,  -- n
</span></span><span class="line"><span class="cl">    publicExponent    INTEGER   -- e
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pkcs-8">PKCS #8</h3>
<p>有前面的分析我们可以知道，PKCS#8 标准定义了一个密钥格式的通用方案，它不仅仅为 RSA 所使用，同样也可以被其它密钥所使用；具体分析参考 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RFC5208-Private-Key-Information-Syntax-Specification"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC5208 Private-Key Information Syntax Specification</a></p>
<p>其所对应的 PEM 格式定义如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PUBLIC KEY-----
</span></span><span class="line"><span class="cl">BASE64 ENCODED DATA
</span></span><span class="line"><span class="cl">-----END PUBLIC KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里就没有 RSA 字样了，因为 PKCS#8 是一个通用型的秘钥格式方案；其中的 <em>BASE64 ENCODED DATA</em> 所标注的内容为 PEM 格式中对 DER 原始二进制进行的 BASE64 编码；</p>
<p>所对应的 DER 原始二进制所表述的内容为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PublicKeyInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  algorithm       AlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  PublicKey       BIT STRING
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">AlgorithmIdentifier ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  algorithm       OBJECT IDENTIFIER,
</span></span><span class="line"><span class="cl">  parameters      ANY DEFINED BY algorithm OPTIONAL
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>重要补充</strong></p>
<p>从这里可以看到，PKCS#8 虽然名字叫做 Private-Key Information Syntax Specification，但是实际上，可以看到，它同样可以用作 Public Key 的格式定义；而 PKCS#8 是站在 PKCS#7 CMS 的基础之上进行编码格式定义的；</p>
<h2 id="私钥-pem-格式">私钥 PEM 格式</h2>
<h3 id="pkcs-1-1">PKCS #1</h3>
<p>PKCS#1 是专门为 RSA 所涉及的，其对应的 PEM 格式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN RSA PRIVATE KEY-----
</span></span><span class="line"><span class="cl">BASE64 ENCODED DATA
</span></span><span class="line"><span class="cl">-----END RSA PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的 <em>BASE64 ENCODED DATA</em> 所标注的内容为 PEM 格式中对 DER 原始二进制进行的 BASE64 编码；</p>
<p>原始的 DER 格式结构，既是 ASN.1 的数据结构，此部分内容参考 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RSA-private-key-syntax-%e7%a7%81%e9%92%a5%e8%af%ad%e6%b3%95"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA private key syntax 私钥语法</a> 小节内容；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RSAPrivateKey ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version           Version,
</span></span><span class="line"><span class="cl">  modulus           INTEGER,  -- n
</span></span><span class="line"><span class="cl">  publicExponent    INTEGER,  -- e
</span></span><span class="line"><span class="cl">  privateExponent   INTEGER,  -- d
</span></span><span class="line"><span class="cl">  prime1            INTEGER,  -- p
</span></span><span class="line"><span class="cl">  prime2            INTEGER,  -- q
</span></span><span class="line"><span class="cl">  exponent1         INTEGER,  -- d mod (p-1)
</span></span><span class="line"><span class="cl">  exponent2         INTEGER,  -- d mod (q-1)
</span></span><span class="line"><span class="cl">  coefficient       INTEGER,  -- (inverse of q) mod p
</span></span><span class="line"><span class="cl">  otherPrimeInfos   OtherPrimeInfos OPTIONAL
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pkcs-8-1">PKCS #8</h3>
<h4 id="未加密">未加密</h4>
<p>其所对应的 PEM 格式定义如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PRIVATE KEY-----
</span></span><span class="line"><span class="cl">BASE64 ENCODED DATA
</span></span><span class="line"><span class="cl">-----END PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意，这里就没有 RSA 字样了，因为 PKCS#8 是一个通用型的秘钥格式方案；其中的 <em>BASE64 ENCODED DATA</em> 所标注的内容为 PEM 格式中对 DER 原始二进制进行的 BASE64 编码；</p>
<p>所对应的 DER 原始二进制所表述的内容为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PrivateKeyInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version         Version,
</span></span><span class="line"><span class="cl">  algorithm       AlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  PrivateKey      BIT STRING
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">AlgorithmIdentifier ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  algorithm       OBJECT IDENTIFIER,
</span></span><span class="line"><span class="cl">  parameters      ANY DEFINED BY algorithm OPTIONAL
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="加密">加密</h4>
<p>由于私钥是非常私密的，所以在存储到时候往往需要对私钥的内容也进行加密，</p>
<p>PEM 格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN ENCRYPTED PRIVATE KEY-----
</span></span><span class="line"><span class="cl">BASE64 ENCODED DATA
</span></span><span class="line"><span class="cl">-----END ENCRYPTED PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>DER 格式，既是根据 ASN.1 标准所定义的格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EncryptedPrivateKeyInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  encryptionAlgorithm  EncryptionAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  encryptedData        EncryptedData
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">EncryptedData ::= OCTET STRING
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
  <title>RSA(二) PKCS 公钥加密标准系列</title>
  <link>https://ronin-zc.com/rsa%E4%BA%8C-pkcs-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86%E7%B3%BB%E5%88%97/</link>
  <pubDate>Wed, 03 Mar 2021 13:41:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E4%BA%8C-pkcs-%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86%E7%B3%BB%E5%88%97/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>本章着重描述 RSA PCKS(Public-Key Cryptography Standards Series 公钥加密标准系列)，RSA 又称为公钥加密技术，主要的使用场景是公钥加密、私钥解密（补充，当然，私钥加密，公钥机密也是可行的，但是这样做并不安全，因为公钥是公开的，所有拿到公钥的人都可以解密，也就失去了加密的本质；不过，可以用私钥来进行签名，后续有专门的博文对此进行描述）；</p>
<p>为了定义 RSA 加密的标准系列，IETF 组织总共定义了 15 个子系列标准，分别用在定义标准格式、如何封装、公钥加密封装标准、私钥加密封装标准、网络传输序列化标准等等.. 具体可以参考 wikipedia PCKS 的解释: <a
  href="https://en.wikipedia.org/wiki/PKCS"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/PKCS</a>；</p>
<p>下面我就几个核心的系列标准进行描述，</p>
<p>重要：本文为作者的原创作品，转载需注明出处；</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/</code></p>
</blockquote>
<p>未完待续….</p>
<h1 id="pkcs-1-rsa-cryptography-standard">PKCS #1 RSA Cryptography Standard</h1>
<p>摘要 wikepedia 中的一段摘要，</p>
<blockquote>
<p>See <a
  href="https://tools.ietf.org/html/rfc3447"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC 3447</a>. Defines the mathematical properties and format of RSA public and private keys (ASN.1-encoded in clear-text), and the basic algorithms and encoding/padding schemes for performing RSA encryption, decryption, and producing and verifying signatures.</p>
</blockquote>
<p>定义了公钥加密技术(RSA)相关的数学属性以及相关的公钥和密钥的格式标准（通过 ASN.1 的格式标准来定义并明文展示），以及为 RSA 进行加密、解密，生成和验证签名等操作定义了基本的算法和编码/补零(padding)的方案；</p>
<p>可以看到，PCKS #1 主要定义了公钥加密技术 RSA 是如何通过计算机来来定义其编码、通讯格式包括公钥私钥的文本格式(通过 ASN.1 来定义)等一系列能够使用计算机来进行通讯和计算的方案；</p>
<p>要注意的是，PCKS #1 定义的都是明文的格式；下面我们来看看 ASN.1 是如何定义私钥和公钥的格式的，来加深我们的认知；</p>
<h2 id="asn1">ASN.1</h2>
<p>ASN.1: <a
  href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One</a></p>
<blockquote>
<p>Abstract Syntax Notation One (ASN.1) is an interface description language for defining data structures that can be serialized and deserialized in a standard, cross-platform way. It’s broadly used in telecommunications and computer networking, and especially in cryptography.</p>
</blockquote>
<p>ASN.1 是一种接口描述性语言，该语言定义了能够进行跨平台、序列化和反序列化的数据格式；它被广泛的用于电子通讯以及计算机网络中，特别是用在<code>密码学的领域</code>；由此可知，ASN.1 定义了一种专用于密码学领域的一种可以进行序列化和反序列化的数据格式；</p>
<blockquote>
<p>ASN.1 is used in X.509, which defines the format of certificates used in the HTTPS protocol for securely browsing the web, and in many other cryptographic systems.</p>
</blockquote>
<p>ASN.1 用在 X.509 中，用来定义其证书的格式，该证书用在 HTTPS 安全通讯领域；</p>
<p>那么 RSA 是如何通过 ASN.1 来定义公钥和私钥的数据格式的；看下面的章节，主要参考，https://tools.ietf.org/html/rfc3447#appendix-A</p>
<h3 id="rsa-public-key-syntax-公钥语法">RSA public key syntax 公钥语法</h3>
<p><a
  href="https://tools.ietf.org/html/rfc3447#appendix-A.1.1"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc3447#appendix-A.1.1</a></p>
<blockquote>
<p>An RSA public key should be represented with the ASN.1 type
RSAPublicKey:</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RSAPublicKey ::= SEQUENCE {
</span></span><span class="line"><span class="cl">    modulus           INTEGER,  -- n
</span></span><span class="line"><span class="cl">    publicExponent    INTEGER   -- e
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>The fields of type RSAPublicKey have the following meanings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">* modulus is the RSA modulus n.
</span></span><span class="line"><span class="cl">* publicExponent is the RSA public exponent e.
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<p>上面通过 ASN.1 定义了公钥的格式，通过一个 ASN.1 的 SEQUENCE 元素分别定义了 modules 和 publicExponent，而 modules 正是代表的 <a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e6%a8%a1-N"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>模 N</a>，而 publicExponent 正式代表的<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e9%9a%8f%e6%9c%ba%e6%95%b0-e"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>随机数 e</a>，而 {𝑁,𝑒}{N,e} 正好表示了公钥；</p>
<p>可见，通过 ASN.1 的 <em>SEQUENCE</em> 元素<code>RSAPublicKey</code>定义了公钥的数据格式，该格式便可以在网络通讯中进行序列化和反序列化；</p>
<h3 id="rsa-private-key-syntax-私钥语法">RSA private key syntax 私钥语法</h3>
<p><a
  href="https://tools.ietf.org/html/rfc3447#appendix-A.1.2"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc3447#appendix-A.1.2</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RSAPrivateKey ::= SEQUENCE {
</span></span><span class="line"><span class="cl">          version           Version,
</span></span><span class="line"><span class="cl">          modulus           INTEGER,  -- n
</span></span><span class="line"><span class="cl">          publicExponent    INTEGER,  -- e
</span></span><span class="line"><span class="cl">          privateExponent   INTEGER,  -- d
</span></span><span class="line"><span class="cl">          prime1            INTEGER,  -- p
</span></span><span class="line"><span class="cl">          prime2            INTEGER,  -- q
</span></span><span class="line"><span class="cl">          exponent1         INTEGER,  -- d mod (p-1)
</span></span><span class="line"><span class="cl">          exponent2         INTEGER,  -- d mod (q-1)
</span></span><span class="line"><span class="cl">          coefficient       INTEGER,  -- (inverse of q) mod p
</span></span><span class="line"><span class="cl">          otherPrimeInfos   OtherPrimeInfos OPTIONAL
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可见，ASN.1 同样通过一个 <em>SEQUENCE</em> 元素<code>RSAPrivateKey</code>定义了私钥的数据格式，d 既是模反元素，p、q 两质数，exponent1 和 exponent2 分别表示 d 与 (p-1) 和 (p-2) 的余数；</p>
<p>可以看到 ASN.1 定义了 private key 的数据格式；</p>
<h2 id="补充">补充</h2>
<p>要查看明文的 public key / private key 的 ASN.1 的源数据格式，可以通过工具 <a
  href="http://phpseclib.sourceforge.net/x509/asn1parse.php"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://phpseclib.sourceforge.net/x509/asn1parse.php</a> 查看；</p>
<h1 id="pkcs-7-cryptographic-message-syntax-standard">PKCS #7 Cryptographic Message Syntax Standard</h1>
<p>Cryptographic Message Syntax Standard 被加密消息的格式标准，与 PKCS #1 不同，PKCS #7 描述的是如何对公钥和私钥 ASN.1 的文本进行加密的标准；PKCS #1 标准描述的是 RSA 加密技术相关标准的定义；先来看 Wikipedia 上的一段摘要，</p>
<blockquote>
<p>See <a
  href="https://tools.ietf.org/html/rfc2315"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC 2315</a>. Used to sign and/or encrypt messages under a <a
  href="https://en.wikipedia.org/wiki/Public_key_infrastructure"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>PKI</a>. Used also for certificate dissemination (for instance as a response to a PKCS #10 message). Formed the basis for S/MIME, which is as of 2010 based on RFC 5652, an updated <a
  href="https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Cryptographic Message Syntax Standard (CMS)</a>. Often used for single sign-on.</p>
</blockquote>
<p>PKCS #7 通常在一个 PKI 中用来签名或者加密信息，也通常用于证书的传递；PKCS #7 的更新版本参考<a
  href="https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>Cryptographic Message Syntax Standard (CMS)</a>；</p>
<p>从上述的描述中可以知道，PKCS #7 主要定义了消息的加密语法标准；</p>
<p>摘要<a
  href="https://tools.ietf.org/html/rfc5652#section-3"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>CMS</a>介绍中的相关重要部分,</p>
<blockquote>
<p>The CMS describes an encapsulation syntax for data protection.</p>
<p>The CMS can support a variety of architectures for certificate-based
key management, such as the one defined by the PKIX (Public Key
Infrastructure using X.509) working group [PROFILE].</p>
</blockquote>
<p>CMS 用来描述数据加密的一种封装语法；</p>
<p>CMS 可以用于支持多种多样的证书管理实现，比如 PKIX (X.509 中的公钥管理的内部实现)；</p>
<p>Ok，从上述的描述中可以看到，PKCS #7 主要用在 PKI/PKIX 领域中，主要是用来进行公钥加密保存、传输等；</p>
<h2 id="pkcs-7-format">PKCS #7 Format</h2>
<p><a
  href="https://crypto.stackexchange.com/questions/37084/is-pkcs7-a-signature-format-or-a-certificate-format"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://crypto.stackexchange.com/questions/37084/is-pkcs7-a-signature-format-or-a-certificate-format</a> 这篇文章对 PKCS #7 进行了比较详细的讨论；摘要部分如下，</p>
<blockquote>
<p>The <em>.p7b</em> or <em>.p7c</em> format is a special case of PKCS#7/CMS: a SignedData structure containing no “content” and zero SignerInfos, but one or more certificates (usually) and/or CRLs (rarely).</p>
</blockquote>
<p>可以知道，如果使用 PKCS#7 原生格式，将会使用 <em>.p7c</em> 后缀名，如果使用的是 CMS，那么使用的是 <em>.p7b</em> 后缀；</p>
<p>从 <a
  href="https://tools.ietf.org/html/rfc5652#section-12.1"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5652#section-12.1</a> 可以看到详细的 ASN.1 中有关 CMS 的标准定义，</p>
<p>摘要部分信息如下，</p>
<ol>
<li>
<p>数据内容信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ContentInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  contentType ContentType,
</span></span><span class="line"><span class="cl">  content [0] EXPLICIT ANY DEFINED BY contentType }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ContentType ::= OBJECT IDENTIFIER
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>数据签名信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SignedData ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version CMSVersion,
</span></span><span class="line"><span class="cl">  digestAlgorithms DigestAlgorithmIdentifiers,
</span></span><span class="line"><span class="cl">  encapContentInfo EncapsulatedContentInfo,
</span></span><span class="line"><span class="cl">  certificates [0] IMPLICIT CertificateSet OPTIONAL,
</span></span><span class="line"><span class="cl">  crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
</span></span><span class="line"><span class="cl">  signerInfos SignerInfos }
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>签名者信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SignerInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version CMSVersion,
</span></span><span class="line"><span class="cl">  sid SignerIdentifier,
</span></span><span class="line"><span class="cl">  digestAlgorithm DigestAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,
</span></span><span class="line"><span class="cl">  signatureAlgorithm SignatureAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  signature SignatureValue,
</span></span><span class="line"><span class="cl">  unsignedAttrs [1] IMPLICIT UnsignedAttributes OPTIONAL }
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>密钥加密算法信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">KeyTransRecipientInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version CMSVersion,  -- always set to 0 or 2
</span></span><span class="line"><span class="cl">  rid RecipientIdentifier,
</span></span><span class="line"><span class="cl">  keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  encryptedKey EncryptedKey }
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>被加密数据的信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EncryptedData ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version CMSVersion,
</span></span><span class="line"><span class="cl">  encryptedContentInfo EncryptedContentInfo,
</span></span><span class="line"><span class="cl">  unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>可见，PKCS#7 定义完整的一整套的用于加密数据，签名，签名者，加密算法等等一系列信息；由此，奠定了其作为 PKI 的基础；</p>
<h2 id="pkcs-7-的用途">PKCS #7 的用途</h2>
<p><a
  href="http://stackoverflow.com/questions/3344527/what-for-are-the-commonly-used-pkcs-standards-pkcs7-pkcs10-and-pkcs12"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>http://stackoverflow.com/questions/3344527/what-for-are-the-commonly-used-pkcs-standards-pkcs7-pkcs10-and-pkcs12</a></p>
<p>摘抄部分如下，</p>
<blockquote>
<p>PKCS#7 lets you sign and encrypt generic data using X.509 certificates. Also PKCS#7 format can be used to store one or more certificates without private keys (private keys can be put as a data payload and encrypted this way).</p>
</blockquote>
<p>PKCS#7 使得你可以通过使用 X.509 证书对普通的数据进行签名和加密；PKCS#7 也可以用来存放不包含私钥的一个或者多个证书；</p>
<h2 id="pki">PKI</h2>
<p>前文提到了，PKCS#7 用来保证 PKI 的加密格式标准，保证公钥证书的安全性；</p>
<p>Public key infrastructure：https://en.wikipedia.org/wiki/Public_key_infrastructure</p>
<p>公钥基础设施，基础设施包含 CA(certificate authority)、RA、VA 等，从 wikipedia 的描述上来看，主要是为了保证公钥证书颁发途径中的安全性、保密性.. 等等相关措施，目的就是为了在公钥证书传递过程中，避免公钥被串改以后信息的不安全性..</p>
<p>TODO，将来准备单独写一章关于 PKI 的博文来详细的描述此类相关内容。</p>
<h1 id="pkcs-8-private-key-information-syntax-standard">PKCS #8 Private-Key Information Syntax Standard</h1>
<p>Private-Key Information Syntax Standard 私钥信息格式标准，看 Wikipedia 的描述，</p>
<blockquote>
<p>See <a
  href="https://tools.ietf.org/html/rfc5958"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC 5958</a>. Used to carry private certificate keypairs (encrypted or unencrypted).</p>
</blockquote>
<p>用来携带<code>加密</code>的或者<code>未加密</code>的私钥证书；也就是说，PKCS#8 定义了私钥的加密和未加密的格式；</p>
<p>备注，最开始 PKCS#8 标准是由 RFC5208 标准定义，但是后来为了更好的支持 PKI 基础设施，由新的标准 RFC 5958 替换了原来的 RFC5208 标准，这部分内容可以从后续部分 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RFC5958-Asymmetric-Key-Packages"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC5958 Asymmetric Key Packages</a>中了解；但因为 RFC5208 更简明，所以，这里首先介绍 RFC5208 的标准内容；</p>
<h2 id="rfc5208-private-key-information-syntax-specification">RFC5208 Private-Key Information Syntax Specification</h2>
<p>该文档中主要包含了两个部分，private key 的原始格式 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#private-key-info"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>private key info</a> 和 private key 的加密格式 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#encrypted-private-key-info"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>encrypted private key info</a>；</p>
<p><a
  href="https://tools.ietf.org/html/rfc5208"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5208</a></p>
<h3 id="private-key-info">private key info</h3>
<p>Private-key information shall have ASN.1 type PrivateKeyInfo:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PrivateKeyInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  version                   Version,
</span></span><span class="line"><span class="cl">  privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  privateKey                PrivateKey,
</span></span><span class="line"><span class="cl">  attributes           [0]  IMPLICIT Attributes OPTIONAL }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Version ::= INTEGER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PrivateKey ::= OCTET STRING
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Attributes ::= SET OF Attribute
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，通过 ASN.1 格式封装了私钥，重要的有两个字段，privateKeyAlgorithm 和 privateKey；</p>
<ul>
<li>
<p>privateKeyAlgorithm
表示采用的是什么算法，可以是 RSA，也可以是其它的算法，比如 DES、AES 等对称加密算法等。</p>
</li>
<li>
<p>privateKey
通过其类型可以知道，是一个</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PrivateKey ::= OCTET STRING
</span></span></code></pre></td></tr></table>
</div>
</div><p>可见，其由一个八位字节字符串组成；这就是私钥的内容，如果采用的是 RSA，那么自然存储的就是 {N,d} 等相关的私钥信息，详情参考<a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RSA-private-key-syntax-%e7%a7%81%e9%92%a5%e8%af%ad%e6%b3%95"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA private key syntax</a>，如果采用的是 DES 算法呢，那么存储的就是 DES key 相关的信息…</p>
</li>
</ul>
<p>摘抄两端核心的内容如下</p>
<blockquote>
<p><strong>privateKeyAlgorithm</strong> identifies the private-key algorithm. One example of a private-key algorithm is PKCS #1’s rsaEncryption [PKCS#1].</p>
</blockquote>
<p>privateKeyAlgorithm 表示私钥所使用的算法，一个例子就是 PKCS#1 所表述的 PKCS#1 的 rsa 加密技术；</p>
<blockquote>
<p><strong>privateKey</strong> is an octet string whose contents are the value of the private key. The interpretation of the contents is defined in the registration of the private-key algorithm. For an RSA private key, for example, the contents are a BER encoding of a value of type RSAPrivateKey.</p>
</blockquote>
<p>privateKey 是一个包含私钥内容的八位字节字符串 octet string，该内容由其加密算法所描述和解释；比如 RSA 私钥，其内容表示一个通过 BER 编码的私钥；</p>
<p>总结一下，</p>
<p>可以看到，PKCS #8 在原来私钥的格式上做了一层抽象封装，这样使得它可以兼容任何的私钥格式；使得 PKCS 的私钥标准可以使用到任何加密算法，这个同 PKCS#1 中定义的 RSA <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RSA-private-key-syntax-%e7%a7%81%e9%92%a5%e8%af%ad%e6%b3%95"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>私钥语法</a>是不同的，PKCS #1 定义的只是特定的 RSA 私钥的语法格式；</p>
<p>Ok，从这里就可以清晰的看到 PKCS 的发展方向了，PKCS 体系已经突破了单纯的 RSA 加密算法，而是扩展到了可以适配任何的加密算法，所以，PKCS 已经成为了一种通用的密码学格式标准。当然，CMS 在此基础上更进一步，建立了 PKI 体系中所需的其它类型信息，包括加密数据，签名，签名者，加密算法等等公钥加密技术基础设施相关的东西，详情参考<a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#PKCS-7-Format"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>PKCS #7 Format</a>部分，而这部分正是 RFC5958 标准淘汰当前 RFC5208 标准的地方，不过精华其实还是在 RFC5208；</p>
<h3 id="encrypted-private-key-info">encrypted private key info</h3>
<p><a
  href="https://tools.ietf.org/html/rfc5208#section-6"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5208#section-6</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">EncryptedPrivateKeyInfo ::= SEQUENCE {
</span></span><span class="line"><span class="cl">  encryptionAlgorithm  EncryptionAlgorithmIdentifier,
</span></span><span class="line"><span class="cl">  encryptedData        EncryptedData }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
</span></span></code></pre></td></tr></table>
</div>
</div><p>相关核心内容摘抄如下，</p>
<blockquote>
<p>The fields of type EncryptedPrivateKeyInfo have the following meanings:</p>
</blockquote>
<p><strong>encryptionAlgorithm</strong> identifies the algorithm under which the private-key information is encrypted. Two examples are <em>PKCS #5’s pbeWithMD2AndDES-CBC</em> and <em>pbeWithMD5AndDES-CBC [PKCS#5]</em>.</p>
<p><strong>encryptionAlgorithm</strong> 字段表示私钥使用什么算法进行加密的；通常使用 PKCS#5 的 <em>MD2AndDES</em> 或者 <em>MD5AndDES</em> 两种加密算法；</p>
<blockquote>
<p><strong>encryptedData</strong> is the result of encrypting the private-key information.</p>
</blockquote>
<p><strong>encryptedData</strong> 是私钥通过加密算法 <strong>encryptionAlgorithm</strong> 加密以后的内容；</p>
<blockquote>
<p>The encryption process involves the following two steps:</p>
<ol>
<li>The private-key information is BER encoded, yielding an octet string.</li>
<li>The result of step 1 is encrypted with the secret key to give an octet string, the result of the encryption process.</li>
</ol>
</blockquote>
<p>加密过程包含两个步骤，</p>
<ol>
<li>私钥的内容通过 BER 编码，并产生相关的八位字节字符串 octet string</li>
<li>第一步产生的结果将会通过密钥(secret key)进行加密并再产生一个 octet string，该 octet string 便是这个加密过程的结果；</li>
</ol>
<p>可以看到，私钥的整个内容都被 <em>encryptionAlgorithm</em> 所指明的加密算法进行了加密；</p>
<h2 id="rfc5958-asymmetric-key-packages">RFC5958 Asymmetric Key Packages</h2>
<p>看看 RFC5958 的 Introduction 章节，</p>
<blockquote>
<p>This document defines the syntax for private-key information and a
Cryptographic Message Syntax (CMS) [RFC5652] content type for it. Private-key information includes a private key for a specified public-key algorithm and a set of attributes. The CMS can be used to digitally sign, digest, authenticate, or encrypt the asymmetric key format content type. This document obsoletes PKCS #8 v1.2 [RFC5208].</p>
</blockquote>
<p>可见 RFC5958 定义了不但私钥的语法还定义了相关的 CMS 的文本类型(content type)；Private-key information 包含了一个特定公钥算法的私钥以及一些列的属性；CMS 可以用来进行数字签名，digest，验证或者用来加密非对称密钥的内容和格式；该文档淘汰了过时的 PKCS #8 v1.2 [RFC5208]；</p>
<p>RFC5958 Asymmetric Key Packages: <a
  href="https://tools.ietf.org/html/rfc5958"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5958</a> 淘汰了过时的 RFC5208 PKCS #8: Private-Key Information Syntax Specification Version 1.2 <a
  href="https://tools.ietf.org/html/rfc5208"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://tools.ietf.org/html/rfc5208</a>；</p>
<p>虽然是淘汰了 RFC5208，不过笔者在阅览完 RFC5208 以后，发现 RFC5208 内容更为清晰易懂，所以，还是打算从 RFC5208 入手进行梳理；这部分内容参考 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#RFC5208-Private-Key-Information-Syntax-Specification"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RFC5208 Private-Key Information Syntax Specification</a></p>
<p>后续 RFC5958 非常详细的描述了有关 CMS 的内容定义，以及私钥加密 ASN.1 格式的定义，这里就不再一一赘述了；</p>
<h3 id="私钥文件的格式">私钥文件的格式</h3>
<p>RFC5958 用不多的篇幅来描述了私钥的文件存储格式；不过以下内容比较零散，主要是翻译官方文档并做一些个人的理解；</p>
<p>该小节主要来讲解私钥的存储格式，看下 RFC5958 中的一段<a
  href="https://tools.ietf.org/html/rfc5958#section-5"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>描述</a>，</p>
<blockquote>
<p>To extract the private-key information from the AsymmetricKeyPackage, the encapsulating layers need to be removed. At a minimum, the outer ContentInfo [RFC5652] layer needs to be removed. If the AsymmetricKeyPackage is encapsulated in a SignedData [RFC5652], then the SignedData and EncapsulatedContentInfo layers [RFC5652] also need to be removed. The same is true for EnvelopedData, EncryptedData, and AuthenticatedData all from [RFC5652] as well as AuthEnvelopedData from [RFC5083].</p>
</blockquote>
<p>这段话的意思就是说，要提取通过 AsymmetricKeyPackage 格式所封装的私钥，必须剥离其外部的封装层；至少，外部的 ContentInfo[RFC5652] 是需要被剥离出去的；如果封装了签名，同样该签名需要被剥离；同样的，如果有其它的封装数据，比如加密的数据，验证的数据等同样需要剥离出去；</p>
<blockquote>
<p>Once all the outer layers are removed, there are as many sets of private-key information as there are OneAsymmetricKey structures. OneAsymmetricKey and PrivateKeyInfo are the same structure; therefore, either can be saved as a <code>.p8</code> file or copied in to the <code>P12</code> KeyBag BAG-TYPE. Removing encapsulating security layers will invalidate any signature and may expose the key to unauthorized disclosure.</p>
</blockquote>
<p>当所有的外部层次都被剥离以后，所剩下的也就是最终私钥的信息结构了；该私钥的信息可以通过<code>.p8</code>格式文件或者是通过<code>P12</code> KeyBag BAG-TYPE 格式进行存储；不过注意的是，通过之前的步骤层层剥离，若将安全层也剥离以后，将会使得任何签名无效并且会将私钥暴露给非授权机构；</p>
<p>下面这段有意思了，基本上阐述了通过<code>.p8</code>格式存储的私钥的格式，不过就是不够细致，也不够生动形象，官网的内容就是这样，点到为止，看得人痛不欲生；</p>
<blockquote>
<p><code>.p8</code> files are sometimes <code>PEM</code>-encoded. When .p8 files are <code>PEM</code> encoded they use the <code>.pem</code> file extension. <code>PEM</code> encoding is</p>
<ul>
<li>either the <code>Base64</code> encoding, from Section 4 of [RFC4648], of the <code>DER</code>-encoded <code>EncryptedPrivateKeyInfo</code> sandwiched between:</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN ENCRYPTED PRIVATE KEY-----
</span></span><span class="line"><span class="cl">-----END ENCRYPTED PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>
<p>or the Base64 encoding, see Section 4 of [RFC4648], of the</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DER
</span></span></code></pre></td></tr></table>
</div>
</div><p>-encoded</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PrivateKeyInfo
</span></span></code></pre></td></tr></table>
</div>
</div><p>sandwiched between:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PRIVATE KEY-----
</span></span><span class="line"><span class="cl">-----END PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</blockquote>
<p>上面这段比较重要了，阐述了密钥通过<code>.p8</code>加密存储的格式，<code>.p8</code>文件是一种通过<code>PEM</code>编码的文件，当<code>.p8</code>文件通过<code>PEM</code>进行编码的时候，它们的文件后缀为<code>.pem</code>；<code>PEM</code>编码格式有两种方式</p>
<ol>
<li>
<p>使用<code>DER</code>编码的<code>EncryptedPrivateKeyInfo</code>通过<code>Base64</code>转码后被包裹下面的两段标识符中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN ENCRYPTED PRIVATE KEY-----
</span></span><span class="line"><span class="cl">-----END ENCRYPTED PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p>看过官网解释，你此时的状态应该是云里雾里的；这里作者想表达的是什么意思呢… 这里就是表示的如果私钥本身是经过加密存储的，既是 RFC5208 中所定义的 <a
  href="https://www.shangyang.me/2017/05/21/encrypt-rsa-pkcs/#encrypted-private-key-info"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>EncryptedPrivateKeyInfo</a> 所表述的信息，那么会使用如上的格式来进行存储；</p>
</li>
<li>
<p>使用<code>DER</code>编码的<code>PrivateKeyInfo</code>通过<code>Base64</code>转码后被包裹下面的两段标识符中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-----BEGIN PRIVATE KEY-----
</span></span><span class="line"><span class="cl">-----END PRIVATE KEY-----
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>PrivateKeyInfo</code>这里表示的就是明文，既是密钥没有经过加密，是通过<code>Base64</code>所存储的明文格式；</p>
</li>
</ol>
<p>更多有关此部分的介绍查看 <a
  href="https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>RSA(三) 密钥的格式</a>部分内容；</p>
]]></description>
</item><item>
  <title>RSA(一) 背后的数学原理</title>
  <link>https://ronin-zc.com/rsa%E4%B8%80-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</link>
  <pubDate>Wed, 03 Mar 2021 13:40:25 &#43;0800</pubDate>
  <author>RoninZc</author>
  <guid>https://ronin-zc.com/rsa%E4%B8%80-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</guid>
  <description><![CDATA[<h1 id="前言">前言</h1>
<p>本篇文章将试图从数学原理上理清 RSA 的加密解密的原理；并写一个简单的加密解密的用例来使用；</p>
<p>备注，本文是作者的原创作品，转载请注明出处。</p>
<blockquote>
<p>转载至<code>https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/</code></p>
</blockquote>
<h1 id="数论相关">数论相关</h1>
<h2 id="模-n">模 N</h2>
<p>随机选择两个大的质数 p 和 q，p 不等于 q, 计算得到 𝑁=𝑝𝑞N=pq</p>
<h2 id="欧拉函数的值-r--𝜑pq">欧拉函数的值 r = 𝜑(pq)</h2>
<p>𝑟=𝜑(𝑝𝑞)=𝜑(𝑝)𝜑(𝑞)=(𝑝−1)(𝑞−1)r=𝜑(pq)=𝜑(p)𝜑(q)=(p−1)(q−1)</p>
<p>欧拉函数值求的是有多少个小于 N 的数与 N 互质，如果 N 本身为质数，那么就有 N-1 个数与 N 互质；</p>
<h2 id="随机数-e">随机数 e</h2>
<p>选择一个整数 e 且 1&lt;𝑒&lt;𝑟1&lt;e&lt;r，使得 e 与 r 互质(两个数的公约数为 1)；取 e 的目的是为了求得 e 关于 r 的<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>模反元素</a> d；</p>
<h2 id="模反元素-d">模反元素 d</h2>
<h3 id="什么是模反元素-d">什么是模反元素 d</h3>
<p>由<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e9%9a%8f%e6%9c%ba%e6%95%b0-e"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>e</a>小节可知，模反元素 d 是 e 关于 r 的模反元素且若模反元素 d 存在，当且仅当 e 与 r 互质；</p>
<p>模反元素的数学意义</p>
<p>𝑒𝑑≡1(mod𝑟)ed≡1(modr)</p>
<p>若 e 与 r 互质，那么总会找到这么一个数 d，使得 ed 和 1 与模 r 同余；通俗的说法既是，ed 除以 r 的余数与 1 除以 r 的余数相等，因为 1 除以 r 的余数恒等于 1，所以 ed 除以 r 的余数为 1，也就推出</p>
<p>𝑒𝑑−1=𝑘𝑟ed−1=kr</p>
<p>，该表达式的意思就是 ed - 1 是 r 的倍数；</p>
<h3 id="如何计算得到-d">如何计算得到 d</h3>
<p>那么如何计算得出此模反元素 d 呢？</p>
<p>根据<a
  href="https://zh.wikipedia.org/wiki/%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97%e7%ae%97%e6%b3%95"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>扩展欧几里得算法</a>的公式有，在(mod𝑟)(modr)之下，</p>
<p>𝑒𝑥+𝑟𝑦=1ex+ry=1</p>
<p>，此时 x 的解既是 e 关于模 r 的一个模反元素；认真的读者读到这里，肯定会产生疑问，上面的公式 𝑒𝑑−1=𝑘𝑟ed−1=kr 怎么看起来与 𝑒𝑥+𝑟𝑦=1ex+ry=1 怎么这么像呢，但是又有差别，我们将公式 𝑒𝑑−1=𝑘𝑟ed−1=kr 调整一下，得到</p>
<p>𝑒𝑑−𝑘𝑟=1…①ed−kr=1…①</p>
<p>将扩展欧几里得算法的公式 𝑒𝑥+𝑟𝑦=1ex+ry=1 的 x、y 值进行替换，x = d, y = k，得到</p>
<p>𝑒𝑑+𝑘𝑟=1…②ed+kr=1…②</p>
<p>什么，两个看似如此矛盾的两个不同的方程(公式 ① 和公式 ②)… 什么意思？谁是对的？谁是错的？</p>
<p>摘抄<a
  href="https://zh.wikipedia.org/wiki/%e6%a8%a1%e5%8f%8d%e5%85%83%e7%b4%a0"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>模反元素</a>中的一段内容如下，</p>
<blockquote>
<p>事实上， 𝑥+𝑘𝑛(𝑘∈ℤ)x+kn(k∈ℤ)都是a关于模n的模逆元，这里我们取最小的正整数解 𝑥(mod𝑛)(𝑥&lt;𝑛)x(modn)(x&lt;n)</p>
</blockquote>
<p>对应到我们的例子中来，也就是 𝑑+𝑘𝑟(𝑘∈ℤ)d+kr(k∈ℤ) 都是 e 关于模 r 的模逆元，这里我们取最小的正整数解 𝑑(mod𝑟)(𝑑&lt;𝑟)d(modr)(d&lt;r)；由此可知，d 的解实际上有无限多个，满足 𝑑+𝑘𝑟(𝑘∈ℤ)d+kr(k∈ℤ)；k 是整数集合，包含正整数、负整数和零；</p>
<p>其实，公式①和公式②其实可以理解为同一个方程，只是 Y 轴（这里指 K 轴）的方向发生了变化而已；</p>
<h1 id="加密和解密">加密和解密</h1>
<p>假设 Bob 想给 Alice 送一个消息 m；</p>
<h2 id="公钥和密钥">公钥和密钥</h2>
<p>在 Alice 端，经过上述的步骤，我们总共得到了 6 个数字，p、q、N、r、e、d；并生成公钥和密钥，公钥就是(𝑁、𝑒)(N、e)组合；秘钥就是(𝑁、𝑑)(N、d)组合；并且 Alice 将公钥发送给 Bob；</p>
<h2 id="加密过程">加密过程</h2>
<p>Bob 想给 Alice 送一个消息 M，他拥有 Alice 的公钥，既是 (𝑁、𝑒)(N、e) 。他使用起先与 Alice 约好的编码格式将 M 转换为一个<code>小于</code> 模 <a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e6%a8%a1-N"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>N</a>，且与 N 互质的整数 m；通常，我们传递的是字符串，但是字符可以转换为对应的 ASCII 码值或者 UNICODE 等整数数值；由于转换后的数字必须要小于 N，所以，一般的做法是，将原来的文本切割为很多小份，然后分别加密，将每一段转换为 m 后再传输；</p>
<p>加密公式，</p>
<p>𝑐≡𝑚𝑒(mod𝑁)c≡me(modN)</p>
<p>将 m 转换为加密数值<code>c</code>，然后 Bob 将<code>c</code>传输给 Alice；那么<code>c</code>是如何计算得到的？其实这个求<code>c</code>的过程非常的简单，直接是</p>
<p>𝑐=𝑚𝑒%𝑁c=me%N</p>
<p>推导过程，𝑢=𝑚𝑒%𝑁u=me%N，因为 𝑢&lt;𝑁u&lt;N 导出 𝑢=𝑢%𝑁u=u%N 导出 𝑐=𝑢c=u 导出 <strong>余数 u</strong> 既是<code>c</code></p>
<p><a
  href="https://l2x.gitbooks.io/understanding-cryptography/docs/chapter-3/rsa.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://l2x.gitbooks.io/understanding-cryptography/docs/chapter-3/rsa.html</a></p>
<h2 id="解密过程">解密过程</h2>
<p>Alice 拿到 Bob 的加密信息<code>c</code>以后，她使用下面的公式来将<code>c</code>解密得到 m：</p>
<p>𝑐𝑑≡𝑚(mod𝑁)cd≡m(modN)</p>
<p>同<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e5%8a%a0%e5%af%86%e8%bf%87%e7%a8%8b"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>加密过程</a>求<code>c</code>一样，这里，得出</p>
<p>𝑚=𝑐𝑑%𝑁m=cd%N</p>
<p>这里的关键问题是，如何得到的解密方程式 𝑐𝑑≡𝑚(mod𝑁)cd≡m(modN)？</p>
<h3 id="公式推导">公式推导</h3>
<p>由加密公式，</p>
<p>𝑐≡𝑚𝑒(mod𝑁)c≡me(modN)</p>
<p>通过<a
  href="https://zh.wikipedia.org/wiki/%e5%90%8c%e9%a4%98"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>同余</a>的基本运算规则
</p>
<p>那么可以得出</p>
<p>𝑐𝑑≡𝑚𝑒𝑑(mod𝑁)cd≡med(modN)</p>
<p>下面相关部分摘要自 wikipedia，稍有不同的是，上述过程的原始消息是 m，下面过程的原始消息是 n</p>
<p></p>
<p>上面推论的重点在于，𝑛(𝑛φ(𝑁))ℎ≡𝑛(1)ℎ(mod𝑁)n(nφ(N))h≡n(1)h(modN) 是怎么导出来的？参考<a
  href="https://zh.wikipedia.org/wiki/%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>欧拉定理</a>
</p>
<p>所以，有 𝑛φ(𝑁)≡1(mod𝑁)nφ(N)≡1(modN)，难道是将 𝑛φ(𝑁)≡1(mod𝑁)nφ(N)≡1(modN) 直接代入 𝑛(𝑛φ(𝑁))ℎn(nφ(N))h，所以得到 𝑛(𝑛φ(𝑁))ℎ≡𝑛(1)ℎ(mod𝑁)n(nφ(N))h≡n(1)h(modN)，除此之外，想不到原因了… 但是在<a
  href="https://zh.wikipedia.org/wiki/%e5%90%8c%e9%a4%98"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>同余</a>中没找到这种参数代入法.. 所以会有些怀疑；好吧，姑且给自己有一个悬念吧..</p>
<p>最终，经过上述的论证，我们得到了解密要用到的公式，</p>
<p>𝑐𝑑≡𝑚(mod𝑁)cd≡m(modN)</p>
<p><a
  href="https://l2x.gitbooks.io/understanding-cryptography/docs/chapter-3/rsa.html"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>https://l2x.gitbooks.io/understanding-cryptography/docs/chapter-3/rsa.html</a></p>
<h1 id="例证">例证</h1>
<p>上面的原理性的东西说了一堆，这里通过一个实际的例子来看看 RSA 是如何做到加密解密的？</p>
<p>Bob 试图通过 RSA 的加密的方式向 Alice 发送数据，</p>
<h2 id="生成密钥">生成密钥</h2>
<p>如下步骤描述了 Alice 如何通过 RSA 算法生成自己的密钥(公钥和公钥)；</p>
<ol>
<li>
<p>模 N，Alice 选择两个质数 5、13，得到</p>
<p>𝑁=5×13=65N=5×13=65</p>
<p>备注，这里选择的时候一定要注意，之前就是因为错选了不是质数的 9，导致入坑很久没爬出来；</p>
</li>
<li>
<p>欧拉函数值 r</p>
<p>𝑟=φ(𝑁)=φ(5)φ(13)=(5−1)(13−1)=48r=φ(N)=φ(5)φ(13)=(5−1)(13−1)=48</p>
</li>
<li>
<p>随机数 e，随机选择 e 且 (1&lt;𝑒&lt;𝑟)(1&lt;e&lt;r)，e 必须与 r 互质，这里，我随机选择一个</p>
<p>𝑒=5e=5</p>
</li>
<li>
<p>求 e 关于 r 的模反元素 d，有公式 𝑒𝑑≡1(mod𝑟)ed≡1(modr) 等价于求解</p>
<p>5×𝑑≡1(mod48)5×d≡1(mod48)</p>
<p>按照</p>
<p>如何计算得到 d</p>
<p>中所介绍的扩展欧几里得算法，得到公式</p>
<p>5×𝑑+48𝑘=15×d+48k=1</p>
<p>，同样也可以按照公式</p>
<p>5×𝑑−48𝑘=15×d−48k=1</p>
<p>来进行求解，两者之间的相互区别在</p>
<p>如何计算得到 d</p>
<p>有详细的描述；</p>
<p>为了计算出 d，我按照求解的公式 5×𝑑−48𝑘=15×d−48k=1 写了一段程序来求解 d，从 k = -20 开始，不断的试探出 d 的取值，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int k = -20;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int e = 5;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int r = 48;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">while( true ){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   int d_mod = (r*k + 1)%e;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if( d_mod == 0 ){
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      int d = ( (r*k + 1)/e );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      System.out.println(&#34;=====&gt; k=&#34;+k+&#34;; d=&#34; + d );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      //break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   //System.out.println(&#34;tried k=&#34;+k);       
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   k ++;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   if( k &gt; 10 ) break;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>求得取值范围如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">=====&gt; k=-17; d=-163
</span></span><span class="line"><span class="cl">=====&gt; k=-12; d=-115
</span></span><span class="line"><span class="cl">=====&gt; k=-7; d=-67
</span></span><span class="line"><span class="cl">=====&gt; k=-2; d=-19
</span></span><span class="line"><span class="cl">=====&gt; k=3; d=29
</span></span><span class="line"><span class="cl">=====&gt; k=8; d=77
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里要求取最小正整数的模反元素，所以取得 d = 29，k = 3；因为这里是按照𝑒𝑑−𝑘𝑟=1ed−kr=1的逻辑进行求解，所以，这里 k 的值为正整数 3，如果是按照扩展欧几里得算法的方式𝑒𝑑+𝑘𝑟=1ed+kr=1求解，那么 k = -3</p>
</li>
</ol>
<p>Ok，至此，重要的 6 个元素已经集合完毕，他们分别是 𝑝=5,𝑞=13,𝑁=65,𝑟=48,𝑒=5,𝑑=29p=5,q=13,N=65,r=48,e=5,d=29</p>
<p>于是，得到<code>公钥</code>为 65,565,5；得到<code>私钥</code>为 65,2965,29；最后 Alice 通过某种方式将<code>公钥</code>发送给 Bob；</p>
<h2 id="传输加密信息">传输加密信息</h2>
<p>Bob 通过 RSA 加密方式向 Alice 发送字符感叹号 !，</p>
<p>首先，将字符 ! 转换成其对应的 ASCII 码值，对应为 41，记为 𝑚m</p>
<p>再次，通过<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e5%8a%a0%e5%af%86%e8%bf%87%e7%a8%8b"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>加密公式</a> 𝑐=𝑚𝑒%𝑁c=me%N 既 𝑐=415%65=6c=415%65=6，由此得到 m 的加密后的数字为 𝑐=6c=6；注意，过程中使用到了 (N,e)；备注，这里可用编程的方式求解，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">System.out.println( Math.pow(41,5) % 65);
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，Bob 将加密数字 c = 6 发送给了 Alice；</p>
<h2 id="解密加密信息">解密加密信息</h2>
<p>Alice 接收到了 Bob 发送的加密数字 c (6)，之后使用私钥(65, 29)进行解密，</p>
<p>首先，根据<a
  href="https://www.shangyang.me/2017/05/19/encrypt-rsa-math/#%e8%a7%a3%e5%af%86%e8%bf%87%e7%a8%8b"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreferrer"
  
  
  
>解密公式</a> 𝑚=𝑐𝑑%𝑁m=cd%N 既 𝑚=629%65m=629%65，解出 𝑚=41m=41，正好得到 Bob 未加密之前的字符 ! 的 ASCII 码，因此，这里成功将其解密；备注，这里可以通过编程的方式求解，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">System.out.println( Math.pow(6,29) % 65);
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="为什么-rsa-很难被破解">为什么 RSA 很难被破解</h1>
<p>因为要通过密文 c 反推得到明文 m，根据解密方程式 𝑚=𝑐𝑑%𝑁m=cd%N 我们知道，</p>
<ol>
<li>在公钥公开的前提下，既是知道 N、e 的前提下，必须要知道 d，才能解密出明文 m；</li>
<li>而要知道 d，那么就必须对素数模 N 进行<code>因式分解</code>，得到 p 和 q，</li>
<li>再通过欧拉函数的计算 𝜑(𝑝𝑞)=𝜑(𝑝)𝜑(𝑞)𝜑(pq)=𝜑(p)𝜑(q) 得到 r，</li>
<li>最后通过 r 和 e，求出 e 于 r 的模反元素的计算才能最终推导出 d；</li>
</ol>
<p>而一切的一切的前提都必须对 N 进行因式分解，而如果 N 是一个非常大的素数，因式分解几乎是不可能的；这样，也就保证了 RSA 的加密技术的可靠性；</p>
<h1 id="使用注意">使用注意</h1>
<p>可以看到，在加密和解密过程中都会涉及到<code>特大指数级别</code>的运算，所以，运算过程是非常耗费计算机资源和时间的；所以一般的通讯中不直接使用 RSA 来进行加密通讯；而是通过公钥加密一段 DES 密钥来进行通讯，比如 Bob 使用 Alice 的<code>公钥</code>生成一个 DES 对称密钥，然后发送给 Alice，然后 Alice 再使用<code>密钥</code>解密得到 DES 密钥，这样双发最后实际上是通过 DES 密钥在进行通讯；</p>
]]></description>
</item></channel>
</rss>
