---
title: 数据库技术基础
date: 2025-02-12T08:00:00+08:00
draft: false
tags:
  - 软考
  - 架构
  - 笔记
categories:
  - 学习
  - 笔记
---

## 数据库系统

### 概述

* 数据: 是数据库中存储的基本对象，是描述事物的符号记录
  * 种类: 文本、图像、音频、视频等
* 数据库（DB）: 是长期存储在计算机内、有组织的、可共享的大量数据的集合
* 数据库的基本特征:
  * 数据可按一定的数据模型组织、描述和存储
  * 可为各种用户共享
  * 冗余度较小
  * 数据独立性较高
  * 易扩展
* 数据库系统（DBS）: 是一个采用了数据库技术，有组织地、动态地存储大量相关数据，方便多用户访问的计算机系统，由下面四部分组成
  * 数据库: 统一管理、长期存储在计算机内的，有组织的相关数据的集合
  * 硬件: 构成计算机系统包括存储数据所需的外部设备
  * 软件: 操作系统、数据库管理系统及应用程序
  * 人员: 系统分析和数据库设计人员、应用程序员、最终用户、数据库管理员DBA
* 数据库管理系统（DBMS）的功能
  * 实现对共享数据有效的组织、管理和存取
  * 包括数据定义、数据库操作、数据库运行管理、数据的存储管理、数据库的建立和维护等

---

### 三级模式-两级映像

{{< image src="https://lsky.ronin-zc.com/i/2025/03/09/67cd3123ef61f.png" alt="三级模式-两级映像" width="50%" >}}

* 内模式: 管理如何存储物理的数据，对应具体物理存储文件
* 模式: 又称为概念模式，就是我们通常使用的基本表，根据应用、需求将物理数据划分为一张张表
* 外模式: 对应数据库中的视图这个级别，将表进行一定的处理后再提供给用户使用


* 外模式-模式映像: 是表和视图时间的映射，存在于概念级和外部级之间，若表中数据发生了修改，只需要修改此映射，而无需修改应用程序
* 模式-内模式映像: 是表和数据的物理存储之间的映射，存在于概念级和内部级之间，若修改了数据的存储方式，只需要修改此映射，而不需要去修改应用程序

---

### 数据库设计

{{< image src="https://lsky.ronin-zc.com/i/2025/03/09/67cd3379064e2.png" alt="数据库设计" width="50%" >}}

* 需求分析: 即分析数据存储的要求，**产出物又数据流图、数据字典、需求说明书**
* 概念结构设计: 就是**设计 E-R 图**，也即实体-关系图，与物理实现无关，说明有哪些实体，实体有哪些属性，实体之间的关系
* 逻辑结构设计: **将 E-R 图，转换成关系模式**，也即转换成实际的表和表中的列属性，这里要考虑很多规范化的东西
* 物理设计: 根据生成的表等概念，**生成物理数据库**

---

### 数据模型

#### 分类

* **关系模型是二维表的形式表示的实体-联系模型**，是将实体-联系模型转换而来的，经过开发人员设计的
* **概念模型是从用户角度进行建模**的，是现实世界信息到信息世界的第一抽象，是真正的实体联系模型
* 网状模型表示实体类型及其实体之间的联系，一个事物和另外几个都有联系，形成一张网
* 面向对象模型是采用面对对象的方法设计数据库，以对象为单位，每个对象包括属性和方法，具有类和基础等特点

#### 模型数据三要素

* 数据结构: 所研究的对象类型的集合
* 数据操作: 对数据库中各种对象的实例允许执行的操作的集合
* 数据的约束条件: 一组完整性规则的集合

#### ER模型

{{< image src="https://lsky.ronin-zc.com/i/2025/03/09/67cd3af9683aa.png" alt="ER模型" width="50%" >}}

* 用 E-R 图来描述概念数据模型，世界是由一组称为实体的基本对象和这些对象之间的联系构成的
  * 椭圆表示属性（一般没有）
    * **实体具有的特性**
    * 分类
      * 简单属性和符合属性
      * 单值属性和多值属性
      * NULL 属性
      * 派生属性
    * 域: 属性的取值范围称为该属性的域
    * 码(key): 唯一标识实体的属性集
  * 长方体表示实体（强实体: 正常长方体、弱实体: 两侧多一条竖线）
    * **客观存在并可相互区别的事物**。可以是具体的人、事、物或抽象概念
    * 弱实体和强实体: 弱实体依赖于强实体的存在而存在
    * 实体集: 具有相同类型和共享相同属性的实体的集合，如学生、课程
  * 菱形表示联系
    * 现实世界中**事物内部以及事物之间的联系**，在 E-R 图中反映为**实体内部的联系和实体之间的联系**
    * 联系的两端要写联系类型（一对多，一对一，多对多）

#### 关系模型

* 关系模型中数据结构是一张**二维表**，由行列组成。用表格结构表达实体集，用外键标识实体间的联系
* 优点
  * 建立在严格的数学概念基础上
  * 概念单一、结构简单、清晰，用户易懂
  * 存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作
* 缺点
  * 由于存取路径透明，查询效率往往不如非关系数据模型

#### ER模型转关系模型

* 每一个实体（强实体）都对应一个关系模型
* 联系分为三种
  * 1:1 联系中，联系可以放到**任意的两端实体中，作为一个属性**（要保证 1:1 的两端关联），也可以转换为一个单独的关系模式
  * 1:N 联系中，联系可以单独作为一个关系模式，也可以在**N端中加入1端实体的主键**
  * M:N 联系中，联系**必须作为一个单独的关系模式，其主键是M和N端的联合主键**

---

### 关系代数

* 并
  * 结果是两张表中所有记录数合并，相同记录只显示一次
  * 符号: ∪
  * 示例: R ∪ S
* 交
  * 结果是两张表中相同的记录
  * 符号: ∩
  * 示例: R ∩ S
* 差
  * 结果是第一张表中有第二张表中没有的记录
  * 符号: −
  * 示例: R − S
* 笛卡尔积
  * 结果是两张表中所有的属性列，并且两张表中每一条记录两两组合成一条记录
  * 符号: ×
  * 示例: R × S
* 投影
  * 实际是按条件选择某关系模式中的某列，列也可以用数字表示
  * 符号: π
  * 示例: π_{A,B}(R)（表示从关系 R 中提取属性 A 和 B）
* 选择
  * 实际是按条件选择某关系模式中的某条记录
  * 符号：σ
  * 示例：σ_{A=5}(R)（表示从关系 R 中选择满足条件 A=5 的元组）
* 自然连接
  * 结果是**显示全部的属性列，但是相同的属性列只显示一次，显示两个关系模式中属性相同且值相同的记录**
  * 符号：⋈
  * 示例：R ⋈ S（表示 R 和 S 在共同属性上的自然连接）

---

### 函数依赖

* 给定一个 X，能唯一确定一个 Y，就称 X 确定 Y，或者说 Y 依赖于 X，例如 `Y = X * X` 函数
* 函数依赖又可扩展以下两种规则
  * 部分函数依赖: A 可确定 C，（A，B）也可以确定 C，**（A，B）中的一部分（即A）可以确定 C，称为部分函数依赖**
  * 传递函数依赖: 当 A 和 B 不等价时，A 可确定 B，B 可确定 C，则 A 可确定 C，是传递函数依赖；若 A 和 B 等价，则不存在传递，直接就可确定 C

```text
(A) ---> (C)
 |        ^
 |        |
 |--------+
 |
(B)

《部分函数依赖》

  (not)
 +------+
 |      |
 v      |
(A)--->(B)--->(C)

《传递函数依赖》

```

#### 公理系统

* 设关系模式 `R<U, F>`
  * `U` 是关系模式 `R` 的属性全集
  * `F` 是关系模式 `R` 的一个函数依赖集
* 对于此关系模式，有以下定律
  * 自反律: 若 `Y ⊆ X ⊆ U`，则 `X -> Y` 被 `F` 所逻辑蕴含
  * 增广律: 若 `X -> Y` 被       `F` 所逻辑蕴含，且 `Z ⊆ U`，则 `XZ -> YZ` 为 `F` 所逻辑蕴含
  * 传递律: 若 `X -> Y` 和 `Y -> Z` 为 `F` 所逻辑蕴含，则 `X -> Z` 为 `F` 所逻辑蕴含
  * 合并规则: 若 `X -> Y`，`X -> Z`，则 `X -> YZ` 为 `F` 所蕴含
  * 伪传递律: 若 `X -> Y`，`WY -> Z`，则 `XW -> Z` 为 `F` 所蕴含
  * 分解规则: 若 `X -> Y`，`Z ⊆ Y`，则 `X -> Z` 为 `F` 所蕴含

---

### 键(码)与约束

> 键与码可以通用，即主键主码代表的含义一样

* 超键: 能**唯一标识**此表的属性的组合
* 候选键: 超键中**去掉冗余的属性**，剩余的属性就是候选键
* 主键: 任选一个候选键，即可作为主键
* 外键: 其他表中的主键
* 主属性: **候选键内的属性为主属性**，其他属性为非主属性

约束

* 实体完整性约束: 即**主键约束，主键值不能为空，也不能重复**
* 参照完整性约束: 即外键约束，**外键必须是其他表中已经存在的主键的值，或者为空**
* 用户自定义完整性约束: **自定义表达式**约束，如设定年龄属性的值必须在 0 到 150 之间

---

### 范式

#### 第一范式（1NF）

关系中每一个分量必须是一个不可分的数据项。通俗的说，第一范式就是表中不允许有小表的存在。

例如如下的员工表，就不属于第一范式

* 员工编号
* 员工姓名
* 出生日期
* 薪资/月
  * 基本工资/月
  * 补贴/月
* 所属部门

#### 第二范式（2NF）

> 消除部分函数依赖

如果**关系 `R` 属于 1NF**，且**每一个非主属性完全函数依赖于任何一个候选码**，则 `R` 属于 2NF

通俗的说， 2NF 就是在 1NF 的基础上，表中的**每一个非主属性不会依赖复合主键中的某一个列**

单主键的表都满足第二范式，对于复合主键的表，例子如下

* 学生表
  * 学号
  * 学生姓名
  * 所在系
  * 系主任姓名
  * 课程号
  * 成绩
* 其中
  * 学号可以确定课程号，所以课程号依赖于学号
  * 学号和课程号可以确定成绩，所以成绩部分函数依赖学号和课程号
  * 所以不满足第二范式，需要进行拆分
    * 学生表(学号，学生姓名，所在系，系主任姓名)
    * 选课表(学号，课程号，成绩)
    * 但是还是不满足第三范式

#### 第三范式（3NF）

> 消除传递依赖

在**满足 2NF 的基础上，表中不存在非主属性对键的传递依赖**

继续第二范式的例子，可以分解为

* 学生表(学号，学生姓名，系编号)
* 系表(系编号，系名，系主任)
* 选课表（学号，课程号，成绩）

#### BC范式（BCNF）

BCNF 是指在**第三范式的基础上进一步消除主属性对键的部分函数依赖和传递依赖**

通俗的来说，就是**在每一种情况下，每一个依赖的左边决定因素都必然包含候选键**

```txt
S---+--->T
    |    |
    |    |
    |    |
    J<---+
```

* 上图中，候选键有两种情况: 组合键 (S,T) 或者 (S,J)，依赖集为 { SJ->T, T->J }
  * 可知 STJ 三个属性都是主属性，因此达到了 3NF
  * 然而第二种情况，即 (S,J) 为候选键的时候，对于依赖 T->J，T 在这种情况不是候选键，即 T->J 的决定因素不包含任意候选键，因此上图不是 BCNF
* 要转换为 BCNF 只需要将依赖 T->J 变为 TS->J 即可


#### 解题方法

* 没有在关系表达式右侧出现过的关键字，一定是候选关键字

---

### 模式分解

* 范式之间的转换一般都是通过拆分属性，即模式分解，将具有部分函数依赖和传递依赖的属性分离出来，来达到一步步优化，一般分为以下两种
  * 保持函数依赖分解
    * 对于关系模式 R，有依赖集 F，若对 R 进行分解，分解出来的多个关系模式，保持原来的依赖集不变，则为保持函数依赖的分解。另外要消除掉冗余依赖（如传递依赖）
    * 实例:
      * 设原关系模式 R(A, B, C)，依赖集 F(A->B, B->C, A->C)
      * 将其分解为两个关系模式 R1(A, B) 和 R2(B, C)
      * 此时 R1 中保持依赖 A->B，R2 保持依赖 B->C
      * 说明分解后的 R1 和 R2 是保持函数依赖的分解，因为 A->C 是一个冗余依赖
  * 无损|有损分解
    * 分解后的关系模式能够还原出原关系模式，就是无损分解，不能还原就是有损分解
      * 就是可以通过函数依赖，可以使用某一个分解后的关系模式推导出原有的关系模式
    * 当分解为**两个关系模式**，可以通过以下定理判断是否无损分解
      * 如果 R 的分解为 p={R1, R2}，F 为 R 所满足的函数依赖集合，分解 p 具有无损连接性的**充分必要条件是 R1∩R2->(R1-R2) 或者 R1∩R2->(R2-R1)**


---

### 并发控制

#### 事务

由一系列操作组成，这些操作，要么全做，要么全不做，拥有以下四中特性

* (操作)**原子性**: 要么全做，要么全不做
* (数据)**一致性**: 事务发生后数据是一致的，例如银行坏账，不会存在 A 账户转出，但是 B 账户没收到的情况
* (执行)**隔离性**: 任一事务的更新操作直到其成功提交的整个过程对其他事物都是不可见的，不同事务之间是隔离的，互不干涉
* (改变)**持续性**: 事务操作的结果是持续性的

事务是并发控制的前提条件，并发控制就是控制不同的事务并发执行，提高系统效率，但是并发控制中存在下面三个问题

* **丢失更新**: 事务 1 对数据 A 进行了修改并写回，事务 2 也对 A 进行了修改并写回，此时事务 2 写回的数据会覆盖事务 1 写回的数据，就丢失了事务 1 对 A 的更新。即对数据 A 的更新会被覆盖
* **不可重复读**: 事务 2 读 A，而后事务 1 对数据 A 进行了修改并写回，此时若事务 2 再读 A，发现数据不对。即一个事务重复读 A 两次，会发现数据 A 有误
* **读脏数据**: 事务 1 对 数据 A 进行了修改后，事务 2 读数据 A，而后事务 1 回滚，数据 A 恢复了原来的值，那么事务 2 对数据 A 做的操作是无效的，读到了脏数据


#### 封锁协议（加锁）

* **X锁是排他锁(写锁)**: 若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，**其他事务都不能再对 A 加任何类型的锁**，直到 T 释放 A 上的锁
* **S锁是共享锁(读锁)**: 若事务 T 对数据对象 A 加上 S 锁，则只允许 T 读取 A，但是不能修改 A，其他事务只能再对 A 加 S 锁（即也能读不能修改），直到 T 释放 A 上的 S 锁
* 共分为三级封锁协议
  * 一级封锁协议: 事务再修改**数据 R 之前必须先对其加 X 锁**，直到事务结束才释放。**可解决丢失更新问题**
  * 二级封锁协议: 在一级封锁协议的基础上加上事务 T 在**读数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁**。**可解决丢失更新、读脏数据问题**
  * 三级封锁协议: 一级封锁协议加上事务 T 在**读取数据 R 之前先对其加 S 锁，直到事务结束才释放**。**可解决丢失更新、读脏数据、数据重复读问题**
